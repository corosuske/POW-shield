   1               		.file	"main.c"
   2               	__SP_L__ = 0x3d
   3               	__SREG__ = 0x3f
   4               	__tmp_reg__ = 0
   5               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
 115               	led0_off:
 116               		.stabd	46,0,0
   1:main.c        **** // (c) 2015 Cultuurnet Vlaanderen
   2:main.c        **** // Developed by: productize.be
   3:main.c        **** 
   4:main.c        **** #include <inttypes.h>
   5:main.c        **** #include <avr/io.h>
   6:main.c        **** #include <avr/interrupt.h>
   7:main.c        **** #include <avr/sleep.h>
   8:main.c        **** #include <avr/wdt.h>
   9:main.c        **** #include <util/delay.h>
  10:main.c        **** #include "uart.h"
  11:main.c        **** 
  12:main.c        **** //// PINOUT ////
  13:main.c        **** 
  14:main.c        **** // IN
  15:main.c        **** #define PIN_POWER_OK   PB3 // digital input
  16:main.c        **** #define PIN_BUTTON     PD2 // INT0, falling edge
  17:main.c        **** #define PIN_WAKE       PD3 // INT1, rising edge
  18:main.c        **** #define PIN_SHUTD_BUSY PD5 // digital input
  19:main.c        **** 
  20:main.c        **** // OUT
  21:main.c        **** #define PIN_RASPI_ON   PA1
  22:main.c        **** #define PIN_NFC_ON     PA0
  23:main.c        **** #define PIN_SHUTDOWN   PD4
  24:main.c        **** 
  25:main.c        **** // RESERVED
  26:main.c        **** #define PIN_GPIO17     PB2
  27:main.c        **** #define PIN_GPIO18     PB1
  28:main.c        **** 
  29:main.c        **** // LED
  30:main.c        **** #define PIN_LED0       PD6
  31:main.c        **** #define PIN_LED1       PB4
  32:main.c        **** #define PIN_LED2       PB0
  33:main.c        **** 
  34:main.c        **** typedef enum {
  35:main.c        ****     MC_BOOT,
  36:main.c        ****     MC_ON,
  37:main.c        ****     MC_WAIT_SHUTDOWN_BUSY,
  38:main.c        ****     MC_WAIT_SHUTDOWN_DONE,
  39:main.c        ****     MC_OFF,
  40:main.c        ****     
  41:main.c        **** } mc_state_t;
  42:main.c        **** 
  43:main.c        **** static mc_state_t state = MC_BOOT;
  44:main.c        **** 
  45:main.c        **** static void setup() {
  46:main.c        ****   // Data Direction Register: configure output for select pins
  47:main.c        ****   PORTA = 0;
  48:main.c        ****   DDRA |= _BV(PIN_RASPI_ON) | _BV(PIN_NFC_ON);
  49:main.c        **** 
  50:main.c        ****   PORTB = 0;
  51:main.c        ****   DDRB |= _BV(PIN_LED1)     | _BV(PIN_LED2) | _BV(PIN_GPIO17) | _BV(PIN_GPIO18);
  52:main.c        ****   DDRB &= ~_BV(PIN_POWER_OK);
  53:main.c        ****   //PORTB &= ~_BV(PIN_POWER_OK); // disable internal pull-up
  54:main.c        ****   PORTB = _BV(PIN_GPIO17) | _BV(PIN_GPIO18);
  55:main.c        **** 
  56:main.c        ****   PORTD = 0;
  57:main.c        ****   //DDRD = _BV(PIN_LED0) | _BV(PIN_SHUTDOWN);
  58:main.c        ****   DDRD = _BV(PIN_LED0) | _BV(PIN_SHUTDOWN) | _BV(PIN_WAKE);
  59:main.c        ****   //DDRD &= ~(_BV(PIN_BUTTON) | _BV(PIN_WAKE) | _BV(PIN_SHUTD_BUSY));
  60:main.c        ****   //PORTD &= ~(_BV(PIN_WAKE) | _BV(PIN_SHUTDOWN)); // disable
  61:main.c        ****   PORTD = _BV(PIN_BUTTON) | _BV(PIN_SHUTDOWN); // internal pull-up for BUTTON
  62:main.c        **** 
  63:main.c        ****   // enable pull-ups
  64:main.c        ****   //MCUCR &= ~_BV(PUD);
  65:main.c        ****   // PORTx -> set output
  66:main.c        ****   // PINx -> toggle output
  67:main.c        ****   // configure interrupts
  68:main.c        ****   // level interrupt for both INT0 and INT1
  69:main.c        ****   // as level interrupt is the only kind that can wake
  70:main.c        ****   // from power down
  71:main.c        ****   MCUCR  = 0; // level interrupts, no disable of pull-ups
  72:main.c        ****   GIMSK  = _BV(INT0);  // enable INT0 only; INT1 is only enabled when raspi is on
  73:main.c        ****   //GIMSK = 0;
  74:main.c        ****   
  75:main.c        ****   //init_uart();
  76:main.c        ****   
  77:main.c        ****   //set_sleep_mode(SLEEP_MODE_POWER_DOWN);
  78:main.c        ****   set_sleep_mode(SLEEP_MODE_IDLE);
  79:main.c        **** 
  80:main.c        ****   // 1 second watchdog timer interrupt (not reset!)
  81:main.c        ****   WDTCSR |= (_BV(WDCE) | _BV(WDE));   // Enable Watchdog Change Enable
  82:main.c        ****   WDTCSR =   _BV(WDIE) |              // Interupt Mode
  83:main.c        ****              _BV(WDP2) | _BV(WDP1);   // Set Timeout to ~1 seconds
  84:main.c        ****   
  85:main.c        ****   sei(); // enable interrupts
  86:main.c        **** }
  87:main.c        **** 
  88:main.c        **** static void led0_on() {
  89:main.c        ****   PORTD |= _BV(PIN_LED0);    
  90:main.c        **** }
  91:main.c        **** 
  92:main.c        **** static void led0_off() {
 118               	.LM0:
 119               	.LFBB1:
 120               	/* prologue: function */
 121               	/* frame size = 0 */
 122               	/* stack size = 0 */
 123               	.L__stack_usage = 0
  93:main.c        ****   PORTD &= ~_BV(PIN_LED0);    
 125               	.LM1:
 126 0000 9698      		cbi 0x12,6
 127 0002 0895      		ret
 129               	.Lscope1:
 131               		.stabd	78,0,0
 134               	led1_off:
 135               		.stabd	46,0,0
  94:main.c        **** }
  95:main.c        **** 
  96:main.c        **** static void led0_toggle() {
  97:main.c        ****   PIND |= _BV(PIN_LED0);    
  98:main.c        **** }
  99:main.c        **** 
 100:main.c        **** static void led1_on() {
 101:main.c        ****   PORTB |= _BV(PIN_LED1);    
 102:main.c        **** }
 103:main.c        **** 
 104:main.c        **** static void led1_off() {
 137               	.LM2:
 138               	.LFBB2:
 139               	/* prologue: function */
 140               	/* frame size = 0 */
 141               	/* stack size = 0 */
 142               	.L__stack_usage = 0
 105:main.c        ****   PORTB &= ~_BV(PIN_LED1);    
 144               	.LM3:
 145 0004 C498      		cbi 0x18,4
 146 0006 0895      		ret
 148               	.Lscope2:
 150               		.stabd	78,0,0
 153               	led2_off:
 154               		.stabd	46,0,0
 106:main.c        **** }
 107:main.c        **** 
 108:main.c        **** static void led1_toggle() {
 109:main.c        ****   PINB |= _BV(PIN_LED1);    
 110:main.c        **** } 
 111:main.c        **** 
 112:main.c        **** static void led2_on() {
 113:main.c        ****   PORTB |= _BV(PIN_LED2);    
 114:main.c        **** }
 115:main.c        **** 
 116:main.c        **** static void led2_off() {
 156               	.LM4:
 157               	.LFBB3:
 158               	/* prologue: function */
 159               	/* frame size = 0 */
 160               	/* stack size = 0 */
 161               	.L__stack_usage = 0
 117:main.c        ****   PORTB &= ~_BV(PIN_LED2);    
 163               	.LM5:
 164 0008 C098      		cbi 0x18,0
 165 000a 0895      		ret
 167               	.Lscope3:
 169               		.stabd	78,0,0
 172               	raspi_on:
 173               		.stabd	46,0,0
 118:main.c        **** }
 119:main.c        **** 
 120:main.c        **** static void led2_toggle() {
 121:main.c        ****   PINB |= _BV(PIN_LED2);    
 122:main.c        **** } 
 123:main.c        **** 
 124:main.c        **** static void raspi_on() {
 175               	.LM6:
 176               	.LFBB4:
 177               	/* prologue: function */
 178               	/* frame size = 0 */
 179               	/* stack size = 0 */
 180               	.L__stack_usage = 0
 125:main.c        ****   PORTA |= _BV(PIN_RASPI_ON);
 182               	.LM7:
 183 000c D99A      		sbi 0x1b,1
 184 000e 88E8      		ldi r24,lo8(-120)
 185 0010 93E1      		ldi r25,lo8(19)
 186               	.LBB60:
 187               	.LBB61:
 188               	.LBB62:
 189               	.LBB63:
 191               	.Ltext1:
   1:/usr/lib/avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay_basic.h ****    All rights reserved.
   4:/usr/lib/avr/include/util/delay_basic.h **** 
   5:/usr/lib/avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/avr/include/util/delay_basic.h **** 
   8:/usr/lib/avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/avr/include/util/delay_basic.h **** 
  11:/usr/lib/avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/avr/include/util/delay_basic.h ****      distribution.
  15:/usr/lib/avr/include/util/delay_basic.h **** 
  16:/usr/lib/avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:/usr/lib/avr/include/util/delay_basic.h **** 
  20:/usr/lib/avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/avr/include/util/delay_basic.h **** 
  32:/usr/lib/avr/include/util/delay_basic.h **** /* $Id$ */
  33:/usr/lib/avr/include/util/delay_basic.h **** 
  34:/usr/lib/avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:/usr/lib/avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:/usr/lib/avr/include/util/delay_basic.h **** 
  37:/usr/lib/avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:/usr/lib/avr/include/util/delay_basic.h **** 
  39:/usr/lib/avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  40:/usr/lib/avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  41:/usr/lib/avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  42:/usr/lib/avr/include/util/delay_basic.h **** #endif
  43:/usr/lib/avr/include/util/delay_basic.h **** 
  44:/usr/lib/avr/include/util/delay_basic.h **** /** \file */
  45:/usr/lib/avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:/usr/lib/avr/include/util/delay_basic.h ****     \code
  47:/usr/lib/avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  48:/usr/lib/avr/include/util/delay_basic.h ****     \endcode
  49:/usr/lib/avr/include/util/delay_basic.h **** 
  50:/usr/lib/avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  51:/usr/lib/avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:/usr/lib/avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:/usr/lib/avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:/usr/lib/avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:/usr/lib/avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:/usr/lib/avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  57:/usr/lib/avr/include/util/delay_basic.h **** 
  58:/usr/lib/avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:/usr/lib/avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:/usr/lib/avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  61:/usr/lib/avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  62:/usr/lib/avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:/usr/lib/avr/include/util/delay_basic.h ****     to the overall delay time.
  64:/usr/lib/avr/include/util/delay_basic.h **** 
  65:/usr/lib/avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:/usr/lib/avr/include/util/delay_basic.h **** 
  67:/usr/lib/avr/include/util/delay_basic.h **** */
  68:/usr/lib/avr/include/util/delay_basic.h **** 
  69:/usr/lib/avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:/usr/lib/avr/include/util/delay_basic.h **** 
  71:/usr/lib/avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:/usr/lib/avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:/usr/lib/avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:/usr/lib/avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:/usr/lib/avr/include/util/delay_basic.h ****     register.
  76:/usr/lib/avr/include/util/delay_basic.h **** 
  77:/usr/lib/avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:/usr/lib/avr/include/util/delay_basic.h ****     can be achieved.
  79:/usr/lib/avr/include/util/delay_basic.h **** */
  80:/usr/lib/avr/include/util/delay_basic.h **** void
  81:/usr/lib/avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:/usr/lib/avr/include/util/delay_basic.h **** {
  83:/usr/lib/avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:/usr/lib/avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:/usr/lib/avr/include/util/delay_basic.h **** 		"brne 1b"
  86:/usr/lib/avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:/usr/lib/avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:/usr/lib/avr/include/util/delay_basic.h **** 	);
  89:/usr/lib/avr/include/util/delay_basic.h **** }
  90:/usr/lib/avr/include/util/delay_basic.h **** 
  91:/usr/lib/avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:/usr/lib/avr/include/util/delay_basic.h **** 
  93:/usr/lib/avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:/usr/lib/avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:/usr/lib/avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:/usr/lib/avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:/usr/lib/avr/include/util/delay_basic.h ****     counter register pair.
  98:/usr/lib/avr/include/util/delay_basic.h **** 
  99:/usr/lib/avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:/usr/lib/avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:/usr/lib/avr/include/util/delay_basic.h ****  */
 102:/usr/lib/avr/include/util/delay_basic.h **** void
 103:/usr/lib/avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:/usr/lib/avr/include/util/delay_basic.h **** {
 105:/usr/lib/avr/include/util/delay_basic.h **** 	__asm__ volatile (
 193               	.LM8:
 194 0012 28EC      		ldi r18,lo8(-56)
 195 0014 30E0      		ldi r19,0
 196               	.L6:
 197 0016 F901      		movw r30,r18
 198               	/* #APP */
 199               	 ;  105 "/usr/lib/avr/include/util/delay_basic.h" 1
 200 0018 3197      		1: sbiw r30,1
 201 001a 01F4      		brne 1b
 202               	 ;  0 "" 2
 203               	/* #NOAPP */
 204 001c 0197      		sbiw r24,1
 205               	.LBE63:
 206               	.LBE62:
 208               	.Ltext2:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/lib/avr/include/util/delay.h **** 
 165:/usr/lib/avr/include/util/delay.h **** #else
 166:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 210               	.LM9:
 211 001e 0097      		sbiw r24,0
 212 0020 01F4      		brne .L6
 213               	.LBE61:
 214               	.LBE60:
 216               	.Ltext3:
 126:main.c        ****   _delay_ms(500);
 127:main.c        ****   // set WAKE as input
 128:main.c        ****   DDRD &= ~_BV(PIN_WAKE);
 218               	.LM10:
 219 0022 8B98      		cbi 0x11,3
 129:main.c        ****   PORTD |= _BV(PIN_WAKE); // with active pull-up
 221               	.LM11:
 222 0024 939A      		sbi 0x12,3
 130:main.c        ****   GIMSK  |= _BV(INT1);  // enable INT1 for WAKE
 224               	.LM12:
 225 0026 8BB7      		in r24,0x3b
 226 0028 8068      		ori r24,lo8(-128)
 227 002a 8BBF      		out 0x3b,r24
 228 002c 0895      		ret
 230               	.Lscope4:
 232               		.stabd	78,0,0
 235               	raspi_off:
 236               		.stabd	46,0,0
 131:main.c        **** }
 132:main.c        **** 
 133:main.c        **** static void raspi_off() {
 238               	.LM13:
 239               	.LFBB5:
 240               	/* prologue: function */
 241               	/* frame size = 0 */
 242               	/* stack size = 0 */
 243               	.L__stack_usage = 0
 134:main.c        ****   PORTA &= ~(_BV(PIN_RASPI_ON));
 245               	.LM14:
 246 002e D998      		cbi 0x1b,1
 135:main.c        ****   GIMSK  &= ~_BV(INT1); // disable INT1 for wake
 248               	.LM15:
 249 0030 8BB7      		in r24,0x3b
 250 0032 8F77      		andi r24,lo8(127)
 251 0034 8BBF      		out 0x3b,r24
 136:main.c        ****   // set WAKE as OUTPUT
 137:main.c        ****   DDRD |= _BV(PIN_WAKE);
 253               	.LM16:
 254 0036 8B9A      		sbi 0x11,3
 138:main.c        ****   // and value HIGH
 139:main.c        ****   PORTD |= _BV(PIN_WAKE);
 256               	.LM17:
 257 0038 939A      		sbi 0x12,3
 258 003a 0895      		ret
 260               	.Lscope5:
 262               		.stabd	78,0,0
 263               		.section	.text.startup,"ax",@progbits
 265               	.global	main
 267               	main:
 268               		.stabd	46,0,0
 140:main.c        **** }
 141:main.c        **** 
 142:main.c        **** static void nfc_on() {
 143:main.c        ****   PORTA |= _BV(PIN_NFC_ON);    
 144:main.c        **** }
 145:main.c        **** 
 146:main.c        **** static void nfc_off() {
 147:main.c        ****   PORTA &= ~_BV(PIN_NFC_ON);    
 148:main.c        **** }
 149:main.c        **** 
 150:main.c        **** static void shutdown_on() {
 151:main.c        ****   PORTD &= ~_BV(PIN_SHUTDOWN);    
 152:main.c        **** }
 153:main.c        **** 
 154:main.c        **** static void shutdown_off() {
 155:main.c        ****   PORTD |= _BV(PIN_SHUTDOWN);    
 156:main.c        **** }
 157:main.c        **** 
 158:main.c        **** static int is_power_ok() {
 159:main.c        ****   return ((PINB & _BV(PIN_POWER_OK)) != 0);
 160:main.c        **** }
 161:main.c        **** 
 162:main.c        **** static int is_shutdown_busy() {
 163:main.c        ****   return ((PIND & _BV(PIN_SHUTD_BUSY)) != 0);
 164:main.c        **** }
 165:main.c        ****       
 166:main.c        **** static void main_init() {
 167:main.c        ****   raspi_off(); // need to set IOs in a certain way to allow powering up the raspi
 168:main.c        ****   led0_on();
 169:main.c        ****   _delay_ms(200);
 170:main.c        ****   led1_on();
 171:main.c        ****   _delay_ms(200);
 172:main.c        ****   led0_off();
 173:main.c        ****   led2_on();
 174:main.c        ****   _delay_ms(200);
 175:main.c        ****   led1_off();
 176:main.c        ****   _delay_ms(200);
 177:main.c        ****   led2_off();
 178:main.c        **** 
 179:main.c        ****   shutdown_off();
 180:main.c        ****   raspi_off();
 181:main.c        ****   nfc_off();
 182:main.c        **** }
 183:main.c        **** 
 184:main.c        **** static volatile uint64_t seconds = 0;
 185:main.c        **** static volatile uint64_t button_pressed = 0;
 186:main.c        **** static volatile int wake_triggered = 0;
 187:main.c        **** static int shutdown_timeout = 0;
 188:main.c        **** 
 189:main.c        **** int main() {
 270               	.LM18:
 271               	.LFBB6:
 272               	/* prologue: function */
 273               	/* frame size = 0 */
 274               	/* stack size = 0 */
 275               	.L__stack_usage = 0
 190:main.c        ****   // safety precausion concerning watchdog reset:
 191:main.c        ****   if(MCUSR & _BV(WDRF)) { // If a reset was caused by the Watchdog Timer...
 277               	.LM19:
 278 0000 04B6      		in __tmp_reg__,0x34
 279 0002 03FE      		sbrs __tmp_reg__,3
 280 0004 00C0      		rjmp .L10
 192:main.c        ****     MCUSR &= ~_BV(WDRF);  // Clear the WDT reset flag
 282               	.LM20:
 283 0006 84B7      		in r24,0x34
 284 0008 877F      		andi r24,lo8(-9)
 285 000a 84BF      		out 0x34,r24
 193:main.c        ****     WDTCSR |= (_BV(WDCE) | _BV(WDE));   // Enable the WD Change Bit
 287               	.LM21:
 288 000c 81B5      		in r24,0x21
 289 000e 8861      		ori r24,lo8(24)
 290 0010 81BD      		out 0x21,r24
 194:main.c        ****     WDTCSR = 0x00;        // Disable the WDT
 292               	.LM22:
 293 0012 11BC      		out 0x21,__zero_reg__
 294               	.L10:
 295               	.LBB150:
 296               	.LBB151:
  47:main.c        ****   DDRA |= _BV(PIN_RASPI_ON) | _BV(PIN_NFC_ON);
 298               	.LM23:
 299 0014 1BBA      		out 0x1b,__zero_reg__
  48:main.c        **** 
 301               	.LM24:
 302 0016 8AB3      		in r24,0x1a
 303 0018 8360      		ori r24,lo8(3)
 304 001a 8ABB      		out 0x1a,r24
  50:main.c        ****   DDRB |= _BV(PIN_LED1)     | _BV(PIN_LED2) | _BV(PIN_GPIO17) | _BV(PIN_GPIO18);
 306               	.LM25:
 307 001c 18BA      		out 0x18,__zero_reg__
  51:main.c        ****   DDRB &= ~_BV(PIN_POWER_OK);
 309               	.LM26:
 310 001e 87B3      		in r24,0x17
 311 0020 8761      		ori r24,lo8(23)
 312 0022 87BB      		out 0x17,r24
  52:main.c        ****   //PORTB &= ~_BV(PIN_POWER_OK); // disable internal pull-up
 314               	.LM27:
 315 0024 BB98      		cbi 0x17,3
  54:main.c        **** 
 317               	.LM28:
 318 0026 86E0      		ldi r24,lo8(6)
 319 0028 88BB      		out 0x18,r24
  56:main.c        ****   //DDRD = _BV(PIN_LED0) | _BV(PIN_SHUTDOWN);
 321               	.LM29:
 322 002a 12BA      		out 0x12,__zero_reg__
  58:main.c        ****   //DDRD &= ~(_BV(PIN_BUTTON) | _BV(PIN_WAKE) | _BV(PIN_SHUTD_BUSY));
 324               	.LM30:
 325 002c 88E5      		ldi r24,lo8(88)
 326 002e 81BB      		out 0x11,r24
  61:main.c        **** 
 328               	.LM31:
 329 0030 84E1      		ldi r24,lo8(20)
 330 0032 82BB      		out 0x12,r24
  71:main.c        ****   GIMSK  = _BV(INT0);  // enable INT0 only; INT1 is only enabled when raspi is on
 332               	.LM32:
 333 0034 15BE      		out 0x35,__zero_reg__
  72:main.c        ****   //GIMSK = 0;
 335               	.LM33:
 336 0036 80E4      		ldi r24,lo8(64)
 337 0038 8BBF      		out 0x3b,r24
  78:main.c        **** 
 339               	.LM34:
 340 003a 85B7      		in r24,0x35
 341 003c 8F7A      		andi r24,lo8(-81)
 342 003e 85BF      		out 0x35,r24
  81:main.c        ****   WDTCSR =   _BV(WDIE) |              // Interupt Mode
 344               	.LM35:
 345 0040 81B5      		in r24,0x21
 346 0042 8861      		ori r24,lo8(24)
 347 0044 81BD      		out 0x21,r24
  82:main.c        ****              _BV(WDP2) | _BV(WDP1);   // Set Timeout to ~1 seconds
 349               	.LM36:
 350 0046 86E4      		ldi r24,lo8(70)
 351 0048 81BD      		out 0x21,r24
  85:main.c        **** }
 353               	.LM37:
 354               	/* #APP */
 355               	 ;  85 "main.c" 1
 356 004a 7894      		sei
 357               	 ;  0 "" 2
 358               	/* #NOAPP */
 359               	.LBE151:
 360               	.LBE150:
 361               	.LBB152:
 362               	.LBB153:
 167:main.c        ****   led0_on();
 364               	.LM38:
 365 004c 00D0      		rcall raspi_off
 366               	.LBB154:
 367               	.LBB155:
  89:main.c        **** }
 369               	.LM39:
 370 004e 969A      		sbi 0x12,6
 371 0050 80ED      		ldi r24,lo8(-48)
 372 0052 97E0      		ldi r25,lo8(7)
 373               	.LBE155:
 374               	.LBE154:
 375               	.LBB156:
 376               	.LBB157:
 377               	.LBB158:
 378               	.LBB159:
 380               	.Ltext4:
 382               	.LM40:
 383 0054 28EC      		ldi r18,lo8(-56)
 384 0056 30E0      		ldi r19,0
 385               	.L12:
 386 0058 F901      		movw r30,r18
 387               	/* #APP */
 388               	 ;  105 "/usr/lib/avr/include/util/delay_basic.h" 1
 389 005a 3197      		1: sbiw r30,1
 390 005c 01F4      		brne 1b
 391               	 ;  0 "" 2
 392               	/* #NOAPP */
 393 005e 0197      		sbiw r24,1
 394               	.LBE159:
 395               	.LBE158:
 397               	.Ltext5:
 399               	.LM41:
 400 0060 0097      		sbiw r24,0
 401 0062 01F4      		brne .L12
 402               	.LBE157:
 403               	.LBE156:
 404               	.LBB160:
 405               	.LBB161:
 407               	.Ltext6:
 101:main.c        **** }
 409               	.LM42:
 410 0064 C49A      		sbi 0x18,4
 411 0066 80ED      		ldi r24,lo8(-48)
 412 0068 97E0      		ldi r25,lo8(7)
 413               	.LBE161:
 414               	.LBE160:
 415               	.LBB162:
 416               	.LBB163:
 417               	.LBB164:
 418               	.LBB165:
 420               	.Ltext7:
 422               	.LM43:
 423 006a 28EC      		ldi r18,lo8(-56)
 424 006c 30E0      		ldi r19,0
 425               	.L14:
 426 006e F901      		movw r30,r18
 427               	/* #APP */
 428               	 ;  105 "/usr/lib/avr/include/util/delay_basic.h" 1
 429 0070 3197      		1: sbiw r30,1
 430 0072 01F4      		brne 1b
 431               	 ;  0 "" 2
 432               	/* #NOAPP */
 433 0074 0197      		sbiw r24,1
 434               	.LBE165:
 435               	.LBE164:
 437               	.Ltext8:
 439               	.LM44:
 440 0076 0097      		sbiw r24,0
 441 0078 01F4      		brne .L14
 442               	.LBE163:
 443               	.LBE162:
 445               	.Ltext9:
 172:main.c        ****   led2_on();
 447               	.LM45:
 448 007a 00D0      		rcall led0_off
 449               	.LBB166:
 450               	.LBB167:
 113:main.c        **** }
 452               	.LM46:
 453 007c C09A      		sbi 0x18,0
 454 007e 80ED      		ldi r24,lo8(-48)
 455 0080 97E0      		ldi r25,lo8(7)
 456               	.LBE167:
 457               	.LBE166:
 458               	.LBB168:
 459               	.LBB169:
 460               	.LBB170:
 461               	.LBB171:
 463               	.Ltext10:
 465               	.LM47:
 466 0082 28EC      		ldi r18,lo8(-56)
 467 0084 30E0      		ldi r19,0
 468               	.L16:
 469 0086 F901      		movw r30,r18
 470               	/* #APP */
 471               	 ;  105 "/usr/lib/avr/include/util/delay_basic.h" 1
 472 0088 3197      		1: sbiw r30,1
 473 008a 01F4      		brne 1b
 474               	 ;  0 "" 2
 475               	/* #NOAPP */
 476 008c 0197      		sbiw r24,1
 477               	.LBE171:
 478               	.LBE170:
 480               	.Ltext11:
 482               	.LM48:
 483 008e 0097      		sbiw r24,0
 484 0090 01F4      		brne .L16
 485               	.LBE169:
 486               	.LBE168:
 488               	.Ltext12:
 175:main.c        ****   _delay_ms(200);
 490               	.LM49:
 491 0092 00D0      		rcall led1_off
 492 0094 80ED      		ldi r24,lo8(-48)
 493 0096 97E0      		ldi r25,lo8(7)
 494               	.LBB172:
 495               	.LBB173:
 496               	.LBB174:
 497               	.LBB175:
 499               	.Ltext13:
 501               	.LM50:
 502 0098 28EC      		ldi r18,lo8(-56)
 503 009a 30E0      		ldi r19,0
 504               	.L18:
 505 009c F901      		movw r30,r18
 506               	/* #APP */
 507               	 ;  105 "/usr/lib/avr/include/util/delay_basic.h" 1
 508 009e 3197      		1: sbiw r30,1
 509 00a0 01F4      		brne 1b
 510               	 ;  0 "" 2
 511               	/* #NOAPP */
 512 00a2 0197      		sbiw r24,1
 513               	.LBE175:
 514               	.LBE174:
 516               	.Ltext14:
 518               	.LM51:
 519 00a4 0097      		sbiw r24,0
 520 00a6 01F4      		brne .L18
 521               	.LBE173:
 522               	.LBE172:
 524               	.Ltext15:
 177:main.c        **** 
 526               	.LM52:
 527 00a8 00D0      		rcall led2_off
 528               	.LBB176:
 529               	.LBB177:
 155:main.c        **** }
 531               	.LM53:
 532 00aa 949A      		sbi 0x12,4
 533               	.LBE177:
 534               	.LBE176:
 180:main.c        ****   nfc_off();
 536               	.LM54:
 537 00ac 00D0      		rcall raspi_off
 538               	.LBB178:
 539               	.LBB179:
 147:main.c        **** }
 541               	.LM55:
 542 00ae D898      		cbi 0x1b,0
 543               	.LBE179:
 544               	.LBE178:
 545               	.LBE153:
 546               	.LBE152:
 195:main.c        ****   }
 196:main.c        **** 
 197:main.c        ****     
 198:main.c        ****   setup();
 199:main.c        ****   //uart_puts("Setup Complete.\r\n");  
 200:main.c        ****   main_init();
 201:main.c        ****   //uart_puts("Init Complete.\r\n");  
 202:main.c        **** 
 203:main.c        **** 
 204:main.c        ****   //nfc_on();
 205:main.c        ****   while (1) {
 206:main.c        ****     if (seconds - button_pressed > 3) {
 207:main.c        ****       button_pressed = 0;
 208:main.c        ****     }
 209:main.c        ****     switch (state) {
 210:main.c        ****         
 211:main.c        ****     case MC_BOOT:
 212:main.c        ****         led0_on();
 213:main.c        ****         led1_on();
 214:main.c        ****         led2_on();
 215:main.c        ****         if (is_power_ok()) {
 216:main.c        ****           state = MC_ON;
 217:main.c        ****           raspi_on();
 218:main.c        ****           nfc_on();
 219:main.c        ****         } else {
 220:main.c        ****           state = MC_OFF;
 221:main.c        ****         }
 222:main.c        ****         break;
 223:main.c        **** 
 224:main.c        ****     case MC_ON:
 225:main.c        ****         led0_toggle();
 226:main.c        ****         led1_off();
 227:main.c        ****         led2_off();
 228:main.c        ****         if (!is_power_ok()) {
 229:main.c        ****           shutdown_on();
 230:main.c        ****           nfc_off();
 231:main.c        ****           _delay_ms(500);
 232:main.c        ****           state = MC_WAIT_SHUTDOWN_BUSY;
 233:main.c        ****           shutdown_timeout = 120;
 234:main.c        ****           break;
 235:main.c        ****         }
 236:main.c        ****         if ((button_pressed > 0) && (seconds - button_pressed < 2)) {
 237:main.c        ****           button_pressed = 0;
 238:main.c        ****           shutdown_on();
 239:main.c        ****           nfc_off();
 240:main.c        ****           _delay_ms(500);
 241:main.c        ****           state = MC_WAIT_SHUTDOWN_BUSY;
 242:main.c        ****           shutdown_timeout = 120;
 243:main.c        ****         }
 244:main.c        ****         break;
 245:main.c        **** 
 246:main.c        ****     case MC_WAIT_SHUTDOWN_BUSY:
 247:main.c        ****         shutdown_timeout -= 1;
 248:main.c        ****         if (shutdown_timeout <= 0) {
 249:main.c        ****           shutdown_off();
 250:main.c        ****           state = MC_WAIT_SHUTDOWN_DONE;
 251:main.c        ****           break;
 252:main.c        ****         }
 253:main.c        ****         button_pressed = 0;
 254:main.c        ****         led0_off();
 255:main.c        ****         led1_toggle();
 256:main.c        ****         led2_off();
 257:main.c        ****         if (is_shutdown_busy()) {
 258:main.c        ****           shutdown_off();
 259:main.c        ****           state = MC_WAIT_SHUTDOWN_DONE;
 260:main.c        ****         }
 261:main.c        ****         break;
 262:main.c        **** 
 263:main.c        ****     case MC_WAIT_SHUTDOWN_DONE:
 264:main.c        ****         shutdown_timeout -= 1;
 265:main.c        ****         if (shutdown_timeout <= 0) {
 266:main.c        ****           raspi_off();
 267:main.c        ****           state = MC_OFF;
 268:main.c        ****           break;
 269:main.c        ****         }
 270:main.c        ****         button_pressed = 0;
 271:main.c        ****         led0_off();
 272:main.c        ****         led1_off();
 273:main.c        ****         led2_toggle();
 274:main.c        ****         if (!is_shutdown_busy()) {
 275:main.c        ****           raspi_off();
 276:main.c        ****           state = MC_OFF;
 548               	.LM56:
 549 00b0 84E0      		ldi r24,lo8(4)
 550 00b2 582E      		mov r5,r24
 551               	.LBB180:
 552               	.LBB181:
 553               	.LBB182:
 554               	.LBB183:
 556               	.Ltext16:
 558               	.LM57:
 559 00b4 90E2      		ldi r25,lo8(32)
 560 00b6 692E      		mov r6,r25
 561 00b8 9EE4      		ldi r25,lo8(78)
 562 00ba 792E      		mov r7,r25
 563               	.LBE183:
 564               	.LBE182:
 565               	.LBE181:
 566               	.LBE180:
 568               	.Ltext17:
 277:main.c        ****         }
 278:main.c        ****         break;
 279:main.c        **** 
 280:main.c        ****     case MC_OFF:
 281:main.c        ****         led0_on();
 282:main.c        ****         _delay_ms(10);
 283:main.c        ****         led0_off();
 284:main.c        ****         led1_off();
 285:main.c        ****         led2_off();
 286:main.c        ****         if (button_pressed > 0) {
 287:main.c        ****           button_pressed = 0;
 288:main.c        ****           if (is_power_ok()) {
 289:main.c        ****             raspi_on();
 290:main.c        ****             nfc_on();
 291:main.c        ****             state = MC_ON;
 570               	.LM58:
 571 00bc 4424      		clr r4
 572 00be 4394      		inc r4
 573               	.LBB187:
 574               	.LBB188:
 575               	.LBB189:
 576               	.LBB190:
 578               	.Ltext18:
 580               	.LM59:
 581 00c0 C8EC      		ldi r28,lo8(-56)
 582 00c2 D0E0      		ldi r29,0
 583               	.LBE190:
 584               	.LBE189:
 585               	.LBE188:
 586               	.LBE187:
 588               	.Ltext19:
 241:main.c        ****           shutdown_timeout = 120;
 590               	.LM60:
 591 00c4 22E0      		ldi r18,lo8(2)
 592 00c6 322E      		mov r3,r18
 242:main.c        ****         }
 594               	.LM61:
 595 00c8 38E7      		ldi r19,lo8(120)
 596 00ca 832E      		mov r8,r19
 597 00cc 912C      		mov r9,__zero_reg__
 598               	.L39:
 206:main.c        ****       button_pressed = 0;
 600               	.LM62:
 601 00ce 2091 0000 		lds r18,seconds
 602 00d2 3091 0000 		lds r19,seconds+1
 603 00d6 4091 0000 		lds r20,seconds+2
 604 00da 5091 0000 		lds r21,seconds+3
 605 00de 6091 0000 		lds r22,seconds+4
 606 00e2 7091 0000 		lds r23,seconds+5
 607 00e6 8091 0000 		lds r24,seconds+6
 608 00ea 9091 0000 		lds r25,seconds+7
 609 00ee A090 0000 		lds r10,button_pressed
 610 00f2 B090 0000 		lds r11,button_pressed+1
 611 00f6 C090 0000 		lds r12,button_pressed+2
 612 00fa D090 0000 		lds r13,button_pressed+3
 613 00fe E090 0000 		lds r14,button_pressed+4
 614 0102 F090 0000 		lds r15,button_pressed+5
 615 0106 0091 0000 		lds r16,button_pressed+6
 616 010a 1091 0000 		lds r17,button_pressed+7
 617 010e 00D0      		rcall __subdi3
 618 0110 A3E0      		ldi r26,lo8(3)
 619 0112 00D0      		rcall __cmpdi2_s8
 620 0114 01F0      		breq .L19
 621 0116 00F0      		brlo .L19
 207:main.c        ****     }
 623               	.LM63:
 624 0118 1092 0000 		sts button_pressed,__zero_reg__
 625 011c 1092 0000 		sts button_pressed+1,__zero_reg__
 626 0120 1092 0000 		sts button_pressed+2,__zero_reg__
 627 0124 1092 0000 		sts button_pressed+3,__zero_reg__
 628 0128 1092 0000 		sts button_pressed+4,__zero_reg__
 629 012c 1092 0000 		sts button_pressed+5,__zero_reg__
 630 0130 1092 0000 		sts button_pressed+6,__zero_reg__
 631 0134 1092 0000 		sts button_pressed+7,__zero_reg__
 632               	.L19:
 209:main.c        ****         
 634               	.LM64:
 635 0138 8091 0000 		lds r24,state
 636 013c 8230      		cpi r24,lo8(2)
 637 013e 01F4      		brne .+2
 638 0140 00C0      		rjmp .L21
 639 0142 00F4      		brsh .L22
 640 0144 8823      		tst r24
 641 0146 01F0      		breq .L23
 642 0148 8130      		cpi r24,lo8(1)
 643 014a 01F0      		breq .L24
 644 014c 00C0      		rjmp .L20
 645               	.L22:
 646 014e 8330      		cpi r24,lo8(3)
 647 0150 01F4      		brne .+2
 648 0152 00C0      		rjmp .L25
 649 0154 8430      		cpi r24,lo8(4)
 650 0156 01F4      		brne .+2
 651 0158 00C0      		rjmp .L26
 652 015a 00C0      		rjmp .L20
 653               	.L23:
 654               	.LBB194:
 655               	.LBB195:
  89:main.c        **** }
 657               	.LM65:
 658 015c 969A      		sbi 0x12,6
 659               	.LBE195:
 660               	.LBE194:
 661               	.LBB196:
 662               	.LBB197:
 101:main.c        **** }
 664               	.LM66:
 665 015e C49A      		sbi 0x18,4
 666               	.LBE197:
 667               	.LBE196:
 668               	.LBB198:
 669               	.LBB199:
 113:main.c        **** }
 671               	.LM67:
 672 0160 C09A      		sbi 0x18,0
 673               	.LBE199:
 674               	.LBE198:
 215:main.c        ****           state = MC_ON;
 676               	.LM68:
 677 0162 B39B      		sbis 0x16,3
 678 0164 00C0      		rjmp .L49
 216:main.c        ****           raspi_on();
 680               	.LM69:
 681 0166 4092 0000 		sts state,r4
 217:main.c        ****           nfc_on();
 683               	.LM70:
 684 016a 00D0      		rcall raspi_on
 685               	.LBB200:
 686               	.LBB201:
 143:main.c        **** }
 688               	.LM71:
 689 016c D89A      		sbi 0x1b,0
 690 016e 00C0      		rjmp .L20
 691               	.L24:
 692               	.LBE201:
 693               	.LBE200:
 694               	.LBB202:
 695               	.LBB203:
  97:main.c        **** }
 697               	.LM72:
 698 0170 869A      		sbi 0x10,6
 699               	.LBE203:
 700               	.LBE202:
 226:main.c        ****         led2_off();
 702               	.LM73:
 703 0172 00D0      		rcall led1_off
 227:main.c        ****         if (!is_power_ok()) {
 705               	.LM74:
 706 0174 00D0      		rcall led2_off
 228:main.c        ****           shutdown_on();
 708               	.LM75:
 709 0176 B399      		sbic 0x16,3
 710 0178 00C0      		rjmp .L28
 711               	.LBB204:
 712               	.LBB205:
 151:main.c        **** }
 714               	.LM76:
 715 017a 9498      		cbi 0x12,4
 716               	.LBE205:
 717               	.LBE204:
 718               	.LBB206:
 719               	.LBB207:
 147:main.c        **** }
 721               	.LM77:
 722 017c D898      		cbi 0x1b,0
 723 017e 88E8      		ldi r24,lo8(-120)
 724 0180 93E1      		ldi r25,lo8(19)
 725               	.L30:
 726               	.LBE207:
 727               	.LBE206:
 728               	.LBB208:
 729               	.LBB209:
 730               	.LBB210:
 731               	.LBB211:
 733               	.Ltext20:
 735               	.LM78:
 736 0182 FE01      		movw r30,r28
 737               	/* #APP */
 738               	 ;  105 "/usr/lib/avr/include/util/delay_basic.h" 1
 739 0184 3197      		1: sbiw r30,1
 740 0186 01F4      		brne 1b
 741               	 ;  0 "" 2
 742               	/* #NOAPP */
 743 0188 0197      		sbiw r24,1
 744               	.LBE211:
 745               	.LBE210:
 747               	.Ltext21:
 749               	.LM79:
 750 018a 0097      		sbiw r24,0
 751 018c 01F4      		brne .L30
 752 018e 00C0      		rjmp .L51
 753               	.L28:
 754               	.LBE209:
 755               	.LBE208:
 757               	.Ltext22:
 236:main.c        ****           button_pressed = 0;
 759               	.LM80:
 760 0190 2091 0000 		lds r18,button_pressed
 761 0194 3091 0000 		lds r19,button_pressed+1
 762 0198 4091 0000 		lds r20,button_pressed+2
 763 019c 5091 0000 		lds r21,button_pressed+3
 764 01a0 6091 0000 		lds r22,button_pressed+4
 765 01a4 7091 0000 		lds r23,button_pressed+5
 766 01a8 8091 0000 		lds r24,button_pressed+6
 767 01ac 9091 0000 		lds r25,button_pressed+7
 768 01b0 A0E0      		ldi r26,0
 769 01b2 00D0      		rcall __cmpdi2_s8
 770 01b4 01F4      		brne .+2
 771 01b6 00C0      		rjmp .L20
 236:main.c        ****           button_pressed = 0;
 773               	.LM81:
 774 01b8 2091 0000 		lds r18,seconds
 775 01bc 3091 0000 		lds r19,seconds+1
 776 01c0 4091 0000 		lds r20,seconds+2
 777 01c4 5091 0000 		lds r21,seconds+3
 778 01c8 6091 0000 		lds r22,seconds+4
 779 01cc 7091 0000 		lds r23,seconds+5
 780 01d0 8091 0000 		lds r24,seconds+6
 781 01d4 9091 0000 		lds r25,seconds+7
 782 01d8 A090 0000 		lds r10,button_pressed
 783 01dc B090 0000 		lds r11,button_pressed+1
 784 01e0 C090 0000 		lds r12,button_pressed+2
 785 01e4 D090 0000 		lds r13,button_pressed+3
 786 01e8 E090 0000 		lds r14,button_pressed+4
 787 01ec F090 0000 		lds r15,button_pressed+5
 788 01f0 0091 0000 		lds r16,button_pressed+6
 789 01f4 1091 0000 		lds r17,button_pressed+7
 790 01f8 00D0      		rcall __subdi3
 791 01fa A1E0      		ldi r26,lo8(1)
 792 01fc 00D0      		rcall __cmpdi2_s8
 793 01fe 01F0      		breq .+4
 794 0200 00F0      		brlo .+2
 795 0202 00C0      		rjmp .L20
 237:main.c        ****           shutdown_on();
 797               	.LM82:
 798 0204 1092 0000 		sts button_pressed,__zero_reg__
 799 0208 1092 0000 		sts button_pressed+1,__zero_reg__
 800 020c 1092 0000 		sts button_pressed+2,__zero_reg__
 801 0210 1092 0000 		sts button_pressed+3,__zero_reg__
 802 0214 1092 0000 		sts button_pressed+4,__zero_reg__
 803 0218 1092 0000 		sts button_pressed+5,__zero_reg__
 804 021c 1092 0000 		sts button_pressed+6,__zero_reg__
 805 0220 1092 0000 		sts button_pressed+7,__zero_reg__
 806               	.LBB212:
 807               	.LBB213:
 151:main.c        **** }
 809               	.LM83:
 810 0224 9498      		cbi 0x12,4
 811               	.LBE213:
 812               	.LBE212:
 813               	.LBB214:
 814               	.LBB215:
 147:main.c        **** }
 816               	.LM84:
 817 0226 D898      		cbi 0x1b,0
 818 0228 88E8      		ldi r24,lo8(-120)
 819 022a 93E1      		ldi r25,lo8(19)
 820               	.L34:
 821               	.LBE215:
 822               	.LBE214:
 823               	.LBB216:
 824               	.LBB217:
 825               	.LBB218:
 826               	.LBB219:
 828               	.Ltext23:
 830               	.LM85:
 831 022c FE01      		movw r30,r28
 832               	/* #APP */
 833               	 ;  105 "/usr/lib/avr/include/util/delay_basic.h" 1
 834 022e 3197      		1: sbiw r30,1
 835 0230 01F4      		brne 1b
 836               	 ;  0 "" 2
 837               	/* #NOAPP */
 838 0232 0197      		sbiw r24,1
 839               	.LBE219:
 840               	.LBE218:
 842               	.Ltext24:
 844               	.LM86:
 845 0234 0097      		sbiw r24,0
 846 0236 01F4      		brne .L34
 847               	.L51:
 848               	.LBE217:
 849               	.LBE216:
 851               	.Ltext25:
 241:main.c        ****           shutdown_timeout = 120;
 853               	.LM87:
 854 0238 3092 0000 		sts state,r3
 242:main.c        ****         }
 856               	.LM88:
 857 023c 9092 0000 		sts shutdown_timeout+1,r9
 858 0240 8092 0000 		sts shutdown_timeout,r8
 859 0244 00C0      		rjmp .L20
 860               	.L21:
 247:main.c        ****         if (shutdown_timeout <= 0) {
 862               	.LM89:
 863 0246 8091 0000 		lds r24,shutdown_timeout
 864 024a 9091 0000 		lds r25,shutdown_timeout+1
 865 024e 0197      		sbiw r24,1
 866 0250 9093 0000 		sts shutdown_timeout+1,r25
 867 0254 8093 0000 		sts shutdown_timeout,r24
 248:main.c        ****           shutdown_off();
 869               	.LM90:
 870 0258 1816      		cp __zero_reg__,r24
 871 025a 1906      		cpc __zero_reg__,r25
 872 025c 04F4      		brge .L52
 253:main.c        ****         led0_off();
 874               	.LM91:
 875 025e 1092 0000 		sts button_pressed,__zero_reg__
 876 0262 1092 0000 		sts button_pressed+1,__zero_reg__
 877 0266 1092 0000 		sts button_pressed+2,__zero_reg__
 878 026a 1092 0000 		sts button_pressed+3,__zero_reg__
 879 026e 1092 0000 		sts button_pressed+4,__zero_reg__
 880 0272 1092 0000 		sts button_pressed+5,__zero_reg__
 881 0276 1092 0000 		sts button_pressed+6,__zero_reg__
 882 027a 1092 0000 		sts button_pressed+7,__zero_reg__
 254:main.c        ****         led1_toggle();
 884               	.LM92:
 885 027e 00D0      		rcall led0_off
 886               	.LBB220:
 887               	.LBB221:
 109:main.c        **** } 
 889               	.LM93:
 890 0280 B49A      		sbi 0x16,4
 891               	.LBE221:
 892               	.LBE220:
 256:main.c        ****         if (is_shutdown_busy()) {
 894               	.LM94:
 895 0282 00D0      		rcall led2_off
 257:main.c        ****           shutdown_off();
 897               	.LM95:
 898 0284 859B      		sbis 0x10,5
 899 0286 00C0      		rjmp .L20
 900               	.L52:
 901               	.LBB222:
 902               	.LBB223:
 155:main.c        **** }
 904               	.LM96:
 905 0288 949A      		sbi 0x12,4
 906               	.LBE223:
 907               	.LBE222:
 259:main.c        ****         }
 909               	.LM97:
 910 028a 83E0      		ldi r24,lo8(3)
 911 028c 8093 0000 		sts state,r24
 912 0290 00C0      		rjmp .L20
 913               	.L25:
 264:main.c        ****         if (shutdown_timeout <= 0) {
 915               	.LM98:
 916 0292 8091 0000 		lds r24,shutdown_timeout
 917 0296 9091 0000 		lds r25,shutdown_timeout+1
 918 029a 0197      		sbiw r24,1
 919 029c 9093 0000 		sts shutdown_timeout+1,r25
 920 02a0 8093 0000 		sts shutdown_timeout,r24
 265:main.c        ****           raspi_off();
 922               	.LM99:
 923 02a4 1816      		cp __zero_reg__,r24
 924 02a6 1906      		cpc __zero_reg__,r25
 925 02a8 04F0      		brlt .L36
 926               	.L50:
 266:main.c        ****           state = MC_OFF;
 928               	.LM100:
 929 02aa 00D0      		rcall raspi_off
 930               	.L49:
 267:main.c        ****           break;
 932               	.LM101:
 933 02ac 5092 0000 		sts state,r5
 268:main.c        ****         }
 935               	.LM102:
 936 02b0 00C0      		rjmp .L20
 937               	.L36:
 270:main.c        ****         led0_off();
 939               	.LM103:
 940 02b2 1092 0000 		sts button_pressed,__zero_reg__
 941 02b6 1092 0000 		sts button_pressed+1,__zero_reg__
 942 02ba 1092 0000 		sts button_pressed+2,__zero_reg__
 943 02be 1092 0000 		sts button_pressed+3,__zero_reg__
 944 02c2 1092 0000 		sts button_pressed+4,__zero_reg__
 945 02c6 1092 0000 		sts button_pressed+5,__zero_reg__
 946 02ca 1092 0000 		sts button_pressed+6,__zero_reg__
 947 02ce 1092 0000 		sts button_pressed+7,__zero_reg__
 271:main.c        ****         led1_off();
 949               	.LM104:
 950 02d2 00D0      		rcall led0_off
 272:main.c        ****         led2_toggle();
 952               	.LM105:
 953 02d4 00D0      		rcall led1_off
 954               	.LBB224:
 955               	.LBB225:
 121:main.c        **** } 
 957               	.LM106:
 958 02d6 B09A      		sbi 0x16,0
 959               	.LBE225:
 960               	.LBE224:
 274:main.c        ****           raspi_off();
 962               	.LM107:
 963 02d8 8599      		sbic 0x10,5
 964 02da 00C0      		rjmp .L20
 965 02dc 00C0      		rjmp .L50
 966               	.L26:
 967               	.LBB226:
 968               	.LBB227:
  89:main.c        **** }
 970               	.LM108:
 971 02de 969A      		sbi 0x12,6
 972               	.LBE227:
 973               	.LBE226:
 974               	.LBB228:
 975               	.LBB186:
 976               	.LBB185:
 977               	.LBB184:
 979               	.Ltext26:
 981               	.LM109:
 982 02e0 C301      		movw r24,r6
 983               	/* #APP */
 984               	 ;  105 "/usr/lib/avr/include/util/delay_basic.h" 1
 985 02e2 0197      		1: sbiw r24,1
 986 02e4 01F4      		brne 1b
 987               	 ;  0 "" 2
 988               	/* #NOAPP */
 989               	.LBE184:
 990               	.LBE185:
 991               	.LBE186:
 992               	.LBE228:
 994               	.Ltext27:
 283:main.c        ****         led1_off();
 996               	.LM110:
 997 02e6 00D0      		rcall led0_off
 284:main.c        ****         led2_off();
 999               	.LM111:
 1000 02e8 00D0      		rcall led1_off
 285:main.c        ****         if (button_pressed > 0) {
 1002               	.LM112:
 1003 02ea 00D0      		rcall led2_off
 286:main.c        ****           button_pressed = 0;
 1005               	.LM113:
 1006 02ec 2091 0000 		lds r18,button_pressed
 1007 02f0 3091 0000 		lds r19,button_pressed+1
 1008 02f4 4091 0000 		lds r20,button_pressed+2
 1009 02f8 5091 0000 		lds r21,button_pressed+3
 1010 02fc 6091 0000 		lds r22,button_pressed+4
 1011 0300 7091 0000 		lds r23,button_pressed+5
 1012 0304 8091 0000 		lds r24,button_pressed+6
 1013 0308 9091 0000 		lds r25,button_pressed+7
 1014 030c A0E0      		ldi r26,0
 1015 030e 00D0      		rcall __cmpdi2_s8
 1016 0310 01F0      		breq .L20
 287:main.c        ****           if (is_power_ok()) {
 1018               	.LM114:
 1019 0312 1092 0000 		sts button_pressed,__zero_reg__
 1020 0316 1092 0000 		sts button_pressed+1,__zero_reg__
 1021 031a 1092 0000 		sts button_pressed+2,__zero_reg__
 1022 031e 1092 0000 		sts button_pressed+3,__zero_reg__
 1023 0322 1092 0000 		sts button_pressed+4,__zero_reg__
 1024 0326 1092 0000 		sts button_pressed+5,__zero_reg__
 1025 032a 1092 0000 		sts button_pressed+6,__zero_reg__
 1026 032e 1092 0000 		sts button_pressed+7,__zero_reg__
 288:main.c        ****             raspi_on();
 1028               	.LM115:
 1029 0332 B39B      		sbis 0x16,3
 1030 0334 00C0      		rjmp .L20
 289:main.c        ****             nfc_on();
 1032               	.LM116:
 1033 0336 00D0      		rcall raspi_on
 1034               	.LBB229:
 1035               	.LBB230:
 143:main.c        **** }
 1037               	.LM117:
 1038 0338 D89A      		sbi 0x1b,0
 1039               	.LBE230:
 1040               	.LBE229:
 1042               	.LM118:
 1043 033a 4092 0000 		sts state,r4
 1044 033e 88E8      		ldi r24,lo8(-120)
 1045 0340 93E1      		ldi r25,lo8(19)
 1046               	.L38:
 1047               	.LBB231:
 1048               	.LBB193:
 1049               	.LBB192:
 1050               	.LBB191:
 1052               	.Ltext28:
 1054               	.LM119:
 1055 0342 FE01      		movw r30,r28
 1056               	/* #APP */
 1057               	 ;  105 "/usr/lib/avr/include/util/delay_basic.h" 1
 1058 0344 3197      		1: sbiw r30,1
 1059 0346 01F4      		brne 1b
 1060               	 ;  0 "" 2
 1061               	/* #NOAPP */
 1062 0348 0197      		sbiw r24,1
 1063               	.LBE191:
 1064               	.LBE192:
 1066               	.Ltext29:
 1068               	.LM120:
 1069 034a 0097      		sbiw r24,0
 1070 034c 01F4      		brne .L38
 1071               	.LBE193:
 1072               	.LBE231:
 1074               	.Ltext30:
 292:main.c        ****             _delay_ms(500);
 293:main.c        ****             button_pressed = 0;
 1076               	.LM121:
 1077 034e 1092 0000 		sts button_pressed,__zero_reg__
 1078 0352 1092 0000 		sts button_pressed+1,__zero_reg__
 1079 0356 1092 0000 		sts button_pressed+2,__zero_reg__
 1080 035a 1092 0000 		sts button_pressed+3,__zero_reg__
 1081 035e 1092 0000 		sts button_pressed+4,__zero_reg__
 1082 0362 1092 0000 		sts button_pressed+5,__zero_reg__
 1083 0366 1092 0000 		sts button_pressed+6,__zero_reg__
 1084 036a 1092 0000 		sts button_pressed+7,__zero_reg__
 1085               	.L20:
 294:main.c        ****           }
 295:main.c        ****         }        
 296:main.c        ****     }
 297:main.c        ****     sleep_mode(); // wait for interrupt or UART RX
 1087               	.LM122:
 1088 036e 85B7      		in r24,0x35
 1089 0370 8062      		ori r24,lo8(32)
 1090 0372 85BF      		out 0x35,r24
 1091               	/* #APP */
 1092               	 ;  297 "main.c" 1
 1093 0374 8895      		sleep
 1094               		
 1095               	 ;  0 "" 2
 1096               	/* #NOAPP */
 1097 0376 85B7      		in r24,0x35
 1098 0378 8F7D      		andi r24,lo8(-33)
 1099 037a 85BF      		out 0x35,r24
 298:main.c        **** 
 299:main.c        ****     /*const uint16_t c = uart_getc();
 300:main.c        ****     if (c == UART_NO_DATA) {
 301:main.c        ****       uart_putc('A');
 302:main.c        ****     }
 303:main.c        ****     else {
 304:main.c        ****       uart_putc(c);
 305:main.c        ****     }*/
 306:main.c        ****     
 307:main.c        ****   }
 1101               	.LM123:
 1102 037c 00C0      		rjmp .L39
 1104               	.Lscope6:
 1106               		.stabd	78,0,0
 1107               		.text
 1109               	.global	__vector_1
 1111               	__vector_1:
 1112               		.stabd	46,0,0
 308:main.c        **** 
 309:main.c        ****   return 0;
 310:main.c        **** 
 311:main.c        **** }
 312:main.c        **** 
 313:main.c        **** ISR(INT0_vect) {
 1114               	.LM124:
 1115               	.LFBB7:
 1116 003c 1F92      		push r1
 1117 003e 0F92      		push r0
 1118 0040 0FB6      		in r0,__SREG__
 1119 0042 0F92      		push r0
 1120 0044 1124      		clr __zero_reg__
 1121 0046 2F93      		push r18
 1122 0048 3F93      		push r19
 1123 004a 4F93      		push r20
 1124 004c 5F93      		push r21
 1125 004e 6F93      		push r22
 1126 0050 7F93      		push r23
 1127 0052 8F93      		push r24
 1128 0054 9F93      		push r25
 1129 0056 AF93      		push r26
 1130               	/* prologue: Signal */
 1131               	/* frame size = 0 */
 1132               	/* stack size = 12 */
 1133               	.L__stack_usage = 12
 314:main.c        ****   if (button_pressed == 0) { button_pressed = seconds; }
 1135               	.LM125:
 1136 0058 2091 0000 		lds r18,button_pressed
 1137 005c 3091 0000 		lds r19,button_pressed+1
 1138 0060 4091 0000 		lds r20,button_pressed+2
 1139 0064 5091 0000 		lds r21,button_pressed+3
 1140 0068 6091 0000 		lds r22,button_pressed+4
 1141 006c 7091 0000 		lds r23,button_pressed+5
 1142 0070 8091 0000 		lds r24,button_pressed+6
 1143 0074 9091 0000 		lds r25,button_pressed+7
 1144 0078 A0E0      		ldi r26,0
 1145 007a 00D0      		rcall __cmpdi2_s8
 1146 007c 01F4      		brne .L53
 1148               	.LM126:
 1149 007e 7091 0000 		lds r23,seconds
 1150 0082 6091 0000 		lds r22,seconds+1
 1151 0086 5091 0000 		lds r21,seconds+2
 1152 008a 4091 0000 		lds r20,seconds+3
 1153 008e 3091 0000 		lds r19,seconds+4
 1154 0092 2091 0000 		lds r18,seconds+5
 1155 0096 9091 0000 		lds r25,seconds+6
 1156 009a 8091 0000 		lds r24,seconds+7
 1157 009e 7093 0000 		sts button_pressed,r23
 1158 00a2 6093 0000 		sts button_pressed+1,r22
 1159 00a6 5093 0000 		sts button_pressed+2,r21
 1160 00aa 4093 0000 		sts button_pressed+3,r20
 1161 00ae 3093 0000 		sts button_pressed+4,r19
 1162 00b2 2093 0000 		sts button_pressed+5,r18
 1163 00b6 9093 0000 		sts button_pressed+6,r25
 1164 00ba 8093 0000 		sts button_pressed+7,r24
 1165               	.L53:
 1166               	/* epilogue start */
 315:main.c        **** }
 1168               	.LM127:
 1169 00be AF91      		pop r26
 1170 00c0 9F91      		pop r25
 1171 00c2 8F91      		pop r24
 1172 00c4 7F91      		pop r23
 1173 00c6 6F91      		pop r22
 1174 00c8 5F91      		pop r21
 1175 00ca 4F91      		pop r20
 1176 00cc 3F91      		pop r19
 1177 00ce 2F91      		pop r18
 1178 00d0 0F90      		pop r0
 1179 00d2 0FBE      		out __SREG__,r0
 1180 00d4 0F90      		pop r0
 1181 00d6 1F90      		pop r1
 1182 00d8 1895      		reti
 1184               	.Lscope7:
 1186               		.stabd	78,0,0
 1188               	.global	__vector_2
 1190               	__vector_2:
 1191               		.stabd	46,0,0
 316:main.c        **** 
 317:main.c        **** ISR(INT1_vect) { 
 1193               	.LM128:
 1194               	.LFBB8:
 1195 00da 1F92      		push r1
 1196 00dc 0F92      		push r0
 1197 00de 0FB6      		in r0,__SREG__
 1198 00e0 0F92      		push r0
 1199 00e2 1124      		clr __zero_reg__
 1200 00e4 8F93      		push r24
 1201 00e6 9F93      		push r25
 1202               	/* prologue: Signal */
 1203               	/* frame size = 0 */
 1204               	/* stack size = 5 */
 1205               	.L__stack_usage = 5
 318:main.c        ****   wake_triggered = 1;
 1207               	.LM129:
 1208 00e8 81E0      		ldi r24,lo8(1)
 1209 00ea 90E0      		ldi r25,0
 1210 00ec 9093 0000 		sts wake_triggered+1,r25
 1211 00f0 8093 0000 		sts wake_triggered,r24
 1212               	/* epilogue start */
 319:main.c        **** }
 1214               	.LM130:
 1215 00f4 9F91      		pop r25
 1216 00f6 8F91      		pop r24
 1217 00f8 0F90      		pop r0
 1218 00fa 0FBE      		out __SREG__,r0
 1219 00fc 0F90      		pop r0
 1220 00fe 1F90      		pop r1
 1221 0100 1895      		reti
 1223               	.Lscope8:
 1225               		.stabd	78,0,0
 1227               	.global	__vector_18
 1229               	__vector_18:
 1230               		.stabd	46,0,0
 320:main.c        **** 
 321:main.c        **** ISR(WDT_OVERFLOW_vect) {
 1232               	.LM131:
 1233               	.LFBB9:
 1234 0102 1F92      		push r1
 1235 0104 0F92      		push r0
 1236 0106 0FB6      		in r0,__SREG__
 1237 0108 0F92      		push r0
 1238 010a 1124      		clr __zero_reg__
 1239 010c 2F93      		push r18
 1240 010e 3F93      		push r19
 1241 0110 4F93      		push r20
 1242 0112 5F93      		push r21
 1243 0114 6F93      		push r22
 1244 0116 7F93      		push r23
 1245 0118 8F93      		push r24
 1246 011a 9F93      		push r25
 1247 011c AF93      		push r26
 1248               	/* prologue: Signal */
 1249               	/* frame size = 0 */
 1250               	/* stack size = 12 */
 1251               	.L__stack_usage = 12
 322:main.c        ****   ++seconds;
 1253               	.LM132:
 1254 011e 2091 0000 		lds r18,seconds
 1255 0122 3091 0000 		lds r19,seconds+1
 1256 0126 4091 0000 		lds r20,seconds+2
 1257 012a 5091 0000 		lds r21,seconds+3
 1258 012e 6091 0000 		lds r22,seconds+4
 1259 0132 7091 0000 		lds r23,seconds+5
 1260 0136 8091 0000 		lds r24,seconds+6
 1261 013a 9091 0000 		lds r25,seconds+7
 1262 013e A1E0      		ldi r26,lo8(1)
 1263 0140 00D0      		rcall __adddi3_s8
 1264 0142 2093 0000 		sts seconds,r18
 1265 0146 3093 0000 		sts seconds+1,r19
 1266 014a 4093 0000 		sts seconds+2,r20
 1267 014e 5093 0000 		sts seconds+3,r21
 1268 0152 6093 0000 		sts seconds+4,r22
 1269 0156 7093 0000 		sts seconds+5,r23
 1270 015a 8093 0000 		sts seconds+6,r24
 1271 015e 9093 0000 		sts seconds+7,r25
 1272               	/* epilogue start */
 323:main.c        **** }
 1274               	.LM133:
 1275 0162 AF91      		pop r26
 1276 0164 9F91      		pop r25
 1277 0166 8F91      		pop r24
 1278 0168 7F91      		pop r23
 1279 016a 6F91      		pop r22
 1280 016c 5F91      		pop r21
 1281 016e 4F91      		pop r20
 1282 0170 3F91      		pop r19
 1283 0172 2F91      		pop r18
 1284 0174 0F90      		pop r0
 1285 0176 0FBE      		out __SREG__,r0
 1286 0178 0F90      		pop r0
 1287 017a 1F90      		pop r1
 1288 017c 1895      		reti
 1290               	.Lscope9:
 1292               		.stabd	78,0,0
 1293               		.local	shutdown_timeout
 1294               		.comm	shutdown_timeout,2,1
 1295               		.local	wake_triggered
 1296               		.comm	wake_triggered,2,1
 1297               		.local	button_pressed
 1298               		.comm	button_pressed,8,1
 1299               		.local	seconds
 1300               		.comm	seconds,8,1
 1301               		.local	state
 1302               		.comm	state,1,1
 1309               	.Letext0:
 1310               		.ident	"GCC: (GNU) 4.8.1"
 1311               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccXJ0O4x.s:2      *ABS*:000000000000003d __SP_L__
     /tmp/ccXJ0O4x.s:3      *ABS*:000000000000003f __SREG__
     /tmp/ccXJ0O4x.s:4      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccXJ0O4x.s:5      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccXJ0O4x.s:115    .text:0000000000000000 led0_off
     /tmp/ccXJ0O4x.s:134    .text:0000000000000004 led1_off
     /tmp/ccXJ0O4x.s:153    .text:0000000000000008 led2_off
     /tmp/ccXJ0O4x.s:172    .text:000000000000000c raspi_on
     /tmp/ccXJ0O4x.s:235    .text:000000000000002e raspi_off
     /tmp/ccXJ0O4x.s:267    .text.startup:0000000000000000 main
     /tmp/ccXJ0O4x.s:1298   .bss:000000000000000c seconds
     /tmp/ccXJ0O4x.s:1296   .bss:0000000000000004 button_pressed
     /tmp/ccXJ0O4x.s:1300   .bss:0000000000000014 state
                             .bss:0000000000000000 shutdown_timeout
     /tmp/ccXJ0O4x.s:1111   .text:000000000000003c __vector_1
     /tmp/ccXJ0O4x.s:1190   .text:00000000000000da __vector_2
     /tmp/ccXJ0O4x.s:1294   .bss:0000000000000002 wake_triggered
     /tmp/ccXJ0O4x.s:1229   .text:0000000000000102 __vector_18

UNDEFINED SYMBOLS
__subdi3
__cmpdi2_s8
__adddi3_s8
__do_clear_bss
