   1               		.file	"main.c"
   2               	__SP_L__ = 0x3d
   3               	__SREG__ = 0x3f
   4               	__tmp_reg__ = 0
   5               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
 115               	led0_off:
 116               		.stabd	46,0,0
   1:main.c        **** // (c) 2015 Cultuurnet Vlaanderen
   2:main.c        **** // Developed by: productize.be
   3:main.c        **** 
   4:main.c        **** #include <inttypes.h>
   5:main.c        **** #include <avr/io.h>
   6:main.c        **** #include <avr/interrupt.h>
   7:main.c        **** #include <avr/sleep.h>
   8:main.c        **** #include <avr/wdt.h>
   9:main.c        **** #include <util/delay.h>
  10:main.c        **** #include "uart.h"
  11:main.c        **** 
  12:main.c        **** //// PINOUT ////
  13:main.c        **** 
  14:main.c        **** // IN
  15:main.c        **** #define PIN_POWER_OK   PB3 // digital input
  16:main.c        **** #define PIN_BUTTON     PD2 // INT0, falling edge
  17:main.c        **** #define PIN_WAKE       PD3 // INT1, rising edge
  18:main.c        **** #define PIN_SHUTD_BUSY PD5 // digital input
  19:main.c        **** 
  20:main.c        **** // OUT
  21:main.c        **** #define PIN_RASPI_ON   PA1
  22:main.c        **** #define PIN_NFC_ON     PA0
  23:main.c        **** #define PIN_SHUTDOWN   PD4
  24:main.c        **** 
  25:main.c        **** // RESERVED
  26:main.c        **** #define PIN_GPIO17     PB2
  27:main.c        **** #define PIN_GPIO18     PB1
  28:main.c        **** 
  29:main.c        **** // LED
  30:main.c        **** #define PIN_LED0       PD6
  31:main.c        **** #define PIN_LED1       PB4
  32:main.c        **** #define PIN_LED2       PB0
  33:main.c        **** 
  34:main.c        **** typedef enum {
  35:main.c        ****     MC_BOOT,
  36:main.c        ****     MC_ON,
  37:main.c        ****     MC_WAIT_SHUTDOWN_BUSY,
  38:main.c        ****     MC_WAIT_SHUTDOWN_DONE,
  39:main.c        ****     MC_OFF,
  40:main.c        ****     
  41:main.c        **** } mc_state_t;
  42:main.c        **** 
  43:main.c        **** static mc_state_t state = MC_BOOT;
  44:main.c        **** 
  45:main.c        **** static void setup() {
  46:main.c        ****   // Data Direction Register: configure output for select pins
  47:main.c        ****   PORTA = 0;
  48:main.c        ****   DDRA |= _BV(PIN_RASPI_ON) | _BV(PIN_NFC_ON);
  49:main.c        **** 
  50:main.c        ****   PORTB = 0;
  51:main.c        ****   DDRB |= _BV(PIN_LED1)     | _BV(PIN_LED2) | _BV(PIN_GPIO17) | _BV(PIN_GPIO18);
  52:main.c        ****   DDRB &= ~_BV(PIN_POWER_OK);
  53:main.c        ****   //PORTB &= ~_BV(PIN_POWER_OK); // disable internal pull-up
  54:main.c        ****   PORTB = _BV(PIN_GPIO17) | _BV(PIN_GPIO18);
  55:main.c        **** 
  56:main.c        ****   PORTD = 0;
  57:main.c        ****   //DDRD = _BV(PIN_LED0) | _BV(PIN_SHUTDOWN);
  58:main.c        ****   DDRD = _BV(PIN_LED0) | _BV(PIN_SHUTDOWN) | _BV(PIN_WAKE);
  59:main.c        ****   //DDRD &= ~(_BV(PIN_BUTTON) | _BV(PIN_WAKE) | _BV(PIN_SHUTD_BUSY));
  60:main.c        ****   //PORTD &= ~(_BV(PIN_WAKE) | _BV(PIN_SHUTDOWN)); // disable
  61:main.c        ****   PORTD = _BV(PIN_BUTTON) | _BV(PIN_SHUTDOWN); // internal pull-up for BUTTON
  62:main.c        **** 
  63:main.c        ****   // enable pull-ups
  64:main.c        ****   //MCUCR &= ~_BV(PUD);
  65:main.c        ****   // PORTx -> set output
  66:main.c        ****   // PINx -> toggle output
  67:main.c        ****   // configure interrupts
  68:main.c        ****   // level interrupt for both INT0 and INT1
  69:main.c        ****   // as level interrupt is the only kind that can wake
  70:main.c        ****   // from power down
  71:main.c        ****   MCUCR  = 0; // level interrupts, no disable of pull-ups
  72:main.c        ****   GIMSK  = _BV(INT0);  // enable INT0 only; INT1 is only enabled when raspi is on
  73:main.c        ****   //GIMSK = 0;
  74:main.c        ****   
  75:main.c        ****   //init_uart();
  76:main.c        ****   
  77:main.c        ****   //set_sleep_mode(SLEEP_MODE_POWER_DOWN);
  78:main.c        ****   set_sleep_mode(SLEEP_MODE_IDLE);
  79:main.c        **** 
  80:main.c        ****   // 1 second watchdog timer interrupt (not reset!)
  81:main.c        ****   WDTCSR |= (_BV(WDCE) | _BV(WDE));   // Enable Watchdog Change Enable
  82:main.c        ****   WDTCSR =   _BV(WDIE) |              // Interupt Mode
  83:main.c        ****              _BV(WDP2) | _BV(WDP1);   // Set Timeout to ~1 seconds
  84:main.c        ****   
  85:main.c        ****   sei(); // enable interrupts
  86:main.c        **** }
  87:main.c        **** 
  88:main.c        **** static void led0_on() {
  89:main.c        ****   PORTD |= _BV(PIN_LED0);    
  90:main.c        **** }
  91:main.c        **** 
  92:main.c        **** static void led0_off() {
 118               	.LM0:
 119               	.LFBB1:
 120               	/* prologue: function */
 121               	/* frame size = 0 */
 122               	/* stack size = 0 */
 123               	.L__stack_usage = 0
  93:main.c        ****   PORTD &= ~_BV(PIN_LED0);    
 125               	.LM1:
 126 0000 9698      		cbi 0x12,6
 127 0002 0895      		ret
 129               	.Lscope1:
 131               		.stabd	78,0,0
 134               	led1_off:
 135               		.stabd	46,0,0
  94:main.c        **** }
  95:main.c        **** 
  96:main.c        **** static void led0_toggle() {
  97:main.c        ****   PIND |= _BV(PIN_LED0);    
  98:main.c        **** }
  99:main.c        **** 
 100:main.c        **** static void led1_on() {
 101:main.c        ****   PORTB |= _BV(PIN_LED1);    
 102:main.c        **** }
 103:main.c        **** 
 104:main.c        **** static void led1_off() {
 137               	.LM2:
 138               	.LFBB2:
 139               	/* prologue: function */
 140               	/* frame size = 0 */
 141               	/* stack size = 0 */
 142               	.L__stack_usage = 0
 105:main.c        ****   PORTB &= ~_BV(PIN_LED1);    
 144               	.LM3:
 145 0004 C498      		cbi 0x18,4
 146 0006 0895      		ret
 148               	.Lscope2:
 150               		.stabd	78,0,0
 153               	led2_off:
 154               		.stabd	46,0,0
 106:main.c        **** }
 107:main.c        **** 
 108:main.c        **** static void led1_toggle() {
 109:main.c        ****   PINB |= _BV(PIN_LED1);    
 110:main.c        **** } 
 111:main.c        **** 
 112:main.c        **** static void led2_on() {
 113:main.c        ****   PORTB |= _BV(PIN_LED2);    
 114:main.c        **** }
 115:main.c        **** 
 116:main.c        **** static void led2_off() {
 156               	.LM4:
 157               	.LFBB3:
 158               	/* prologue: function */
 159               	/* frame size = 0 */
 160               	/* stack size = 0 */
 161               	.L__stack_usage = 0
 117:main.c        ****   PORTB &= ~_BV(PIN_LED2);    
 163               	.LM5:
 164 0008 C098      		cbi 0x18,0
 165 000a 0895      		ret
 167               	.Lscope3:
 169               		.stabd	78,0,0
 172               	raspi_on:
 173               		.stabd	46,0,0
 118:main.c        **** }
 119:main.c        **** 
 120:main.c        **** static void led2_toggle() {
 121:main.c        ****   PINB |= _BV(PIN_LED2);    
 122:main.c        **** } 
 123:main.c        **** 
 124:main.c        **** static void raspi_on() {
 175               	.LM6:
 176               	.LFBB4:
 177               	/* prologue: function */
 178               	/* frame size = 0 */
 179               	/* stack size = 0 */
 180               	.L__stack_usage = 0
 125:main.c        ****   PORTA |= _BV(PIN_RASPI_ON);
 182               	.LM7:
 183 000c D99A      		sbi 0x1b,1
 184 000e 88E8      		ldi r24,lo8(-120)
 185 0010 93E1      		ldi r25,lo8(19)
 186               	.LBB60:
 187               	.LBB61:
 188               	.LBB62:
 189               	.LBB63:
 191               	.Ltext1:
   1:/usr/lib/avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay_basic.h ****    All rights reserved.
   4:/usr/lib/avr/include/util/delay_basic.h **** 
   5:/usr/lib/avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/avr/include/util/delay_basic.h **** 
   8:/usr/lib/avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/avr/include/util/delay_basic.h **** 
  11:/usr/lib/avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/avr/include/util/delay_basic.h ****      distribution.
  15:/usr/lib/avr/include/util/delay_basic.h **** 
  16:/usr/lib/avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:/usr/lib/avr/include/util/delay_basic.h **** 
  20:/usr/lib/avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/avr/include/util/delay_basic.h **** 
  32:/usr/lib/avr/include/util/delay_basic.h **** /* $Id$ */
  33:/usr/lib/avr/include/util/delay_basic.h **** 
  34:/usr/lib/avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:/usr/lib/avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:/usr/lib/avr/include/util/delay_basic.h **** 
  37:/usr/lib/avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:/usr/lib/avr/include/util/delay_basic.h **** 
  39:/usr/lib/avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  40:/usr/lib/avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  41:/usr/lib/avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  42:/usr/lib/avr/include/util/delay_basic.h **** #endif
  43:/usr/lib/avr/include/util/delay_basic.h **** 
  44:/usr/lib/avr/include/util/delay_basic.h **** /** \file */
  45:/usr/lib/avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:/usr/lib/avr/include/util/delay_basic.h ****     \code
  47:/usr/lib/avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  48:/usr/lib/avr/include/util/delay_basic.h ****     \endcode
  49:/usr/lib/avr/include/util/delay_basic.h **** 
  50:/usr/lib/avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  51:/usr/lib/avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:/usr/lib/avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:/usr/lib/avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:/usr/lib/avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:/usr/lib/avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:/usr/lib/avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  57:/usr/lib/avr/include/util/delay_basic.h **** 
  58:/usr/lib/avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:/usr/lib/avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:/usr/lib/avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  61:/usr/lib/avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  62:/usr/lib/avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:/usr/lib/avr/include/util/delay_basic.h ****     to the overall delay time.
  64:/usr/lib/avr/include/util/delay_basic.h **** 
  65:/usr/lib/avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:/usr/lib/avr/include/util/delay_basic.h **** 
  67:/usr/lib/avr/include/util/delay_basic.h **** */
  68:/usr/lib/avr/include/util/delay_basic.h **** 
  69:/usr/lib/avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:/usr/lib/avr/include/util/delay_basic.h **** 
  71:/usr/lib/avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:/usr/lib/avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:/usr/lib/avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:/usr/lib/avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:/usr/lib/avr/include/util/delay_basic.h ****     register.
  76:/usr/lib/avr/include/util/delay_basic.h **** 
  77:/usr/lib/avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:/usr/lib/avr/include/util/delay_basic.h ****     can be achieved.
  79:/usr/lib/avr/include/util/delay_basic.h **** */
  80:/usr/lib/avr/include/util/delay_basic.h **** void
  81:/usr/lib/avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:/usr/lib/avr/include/util/delay_basic.h **** {
  83:/usr/lib/avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:/usr/lib/avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:/usr/lib/avr/include/util/delay_basic.h **** 		"brne 1b"
  86:/usr/lib/avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:/usr/lib/avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:/usr/lib/avr/include/util/delay_basic.h **** 	);
  89:/usr/lib/avr/include/util/delay_basic.h **** }
  90:/usr/lib/avr/include/util/delay_basic.h **** 
  91:/usr/lib/avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:/usr/lib/avr/include/util/delay_basic.h **** 
  93:/usr/lib/avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:/usr/lib/avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:/usr/lib/avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:/usr/lib/avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:/usr/lib/avr/include/util/delay_basic.h ****     counter register pair.
  98:/usr/lib/avr/include/util/delay_basic.h **** 
  99:/usr/lib/avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:/usr/lib/avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:/usr/lib/avr/include/util/delay_basic.h ****  */
 102:/usr/lib/avr/include/util/delay_basic.h **** void
 103:/usr/lib/avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:/usr/lib/avr/include/util/delay_basic.h **** {
 105:/usr/lib/avr/include/util/delay_basic.h **** 	__asm__ volatile (
 193               	.LM8:
 194 0012 28EC      		ldi r18,lo8(-56)
 195 0014 30E0      		ldi r19,0
 196               	.L5:
 197 0016 F901      		movw r30,r18
 198               	/* #APP */
 199               	 ;  105 "/usr/lib/avr/include/util/delay_basic.h" 1
 200 0018 3197      		1: sbiw r30,1
 201 001a 01F4      		brne 1b
 202               	 ;  0 "" 2
 203               	/* #NOAPP */
 204 001c 0197      		sbiw r24,1
 205               	.LBE63:
 206               	.LBE62:
 208               	.Ltext2:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/lib/avr/include/util/delay.h **** 
 165:/usr/lib/avr/include/util/delay.h **** #else
 166:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 210               	.LM9:
 211 001e 01F4      		brne .L5
 212               	.LBE61:
 213               	.LBE60:
 215               	.Ltext3:
 126:main.c        ****   _delay_ms(500);
 127:main.c        ****   // set WAKE as input
 128:main.c        ****   DDRD &= ~_BV(PIN_WAKE);
 217               	.LM10:
 218 0020 8B98      		cbi 0x11,3
 129:main.c        ****   PORTD |= _BV(PIN_WAKE); // with active pull-up
 220               	.LM11:
 221 0022 939A      		sbi 0x12,3
 130:main.c        ****   GIMSK  |= _BV(INT1);  // enable INT1 for WAKE
 223               	.LM12:
 224 0024 8BB7      		in r24,0x3b
 225 0026 8068      		ori r24,lo8(-128)
 226 0028 8BBF      		out 0x3b,r24
 227 002a 0895      		ret
 229               	.Lscope4:
 231               		.stabd	78,0,0
 234               	raspi_off:
 235               		.stabd	46,0,0
 131:main.c        **** }
 132:main.c        **** 
 133:main.c        **** static void raspi_off() {
 237               	.LM13:
 238               	.LFBB5:
 239               	/* prologue: function */
 240               	/* frame size = 0 */
 241               	/* stack size = 0 */
 242               	.L__stack_usage = 0
 134:main.c        ****   PORTA &= ~(_BV(PIN_RASPI_ON));
 244               	.LM14:
 245 002c D998      		cbi 0x1b,1
 135:main.c        ****   GIMSK  &= ~_BV(INT1); // disable INT1 for wake
 247               	.LM15:
 248 002e 8BB7      		in r24,0x3b
 249 0030 8F77      		andi r24,lo8(127)
 250 0032 8BBF      		out 0x3b,r24
 136:main.c        ****   // set WAKE as OUTPUT
 137:main.c        ****   DDRD |= _BV(PIN_WAKE);
 252               	.LM16:
 253 0034 8B9A      		sbi 0x11,3
 138:main.c        ****   // and value HIGH
 139:main.c        ****   PORTD |= _BV(PIN_WAKE);
 255               	.LM17:
 256 0036 939A      		sbi 0x12,3
 257 0038 0895      		ret
 259               	.Lscope5:
 261               		.stabd	78,0,0
 262               		.section	.text.startup,"ax",@progbits
 264               	.global	main
 266               	main:
 267               		.stabd	46,0,0
 140:main.c        **** }
 141:main.c        **** 
 142:main.c        **** static void nfc_on() {
 143:main.c        ****   PORTA |= _BV(PIN_NFC_ON);    
 144:main.c        **** }
 145:main.c        **** 
 146:main.c        **** static void nfc_off() {
 147:main.c        ****   PORTA &= ~_BV(PIN_NFC_ON);    
 148:main.c        **** }
 149:main.c        **** 
 150:main.c        **** static void shutdown_on() {
 151:main.c        ****   PORTD &= ~_BV(PIN_SHUTDOWN);    
 152:main.c        **** }
 153:main.c        **** 
 154:main.c        **** static void shutdown_off() {
 155:main.c        ****   PORTD |= _BV(PIN_SHUTDOWN);    
 156:main.c        **** }
 157:main.c        **** 
 158:main.c        **** static int is_power_ok() {
 159:main.c        ****   return ((PINB & _BV(PIN_POWER_OK)) != 0);
 160:main.c        **** }
 161:main.c        **** 
 162:main.c        **** static int is_shutdown_busy() {
 163:main.c        ****   return ((PIND & _BV(PIN_SHUTD_BUSY)) != 0);
 164:main.c        **** }
 165:main.c        ****       
 166:main.c        **** static void main_init() {
 167:main.c        ****   raspi_off(); // need to set IOs in a certain way to allow powering up the raspi
 168:main.c        ****   led0_on();
 169:main.c        ****   _delay_ms(200);
 170:main.c        ****   led1_on();
 171:main.c        ****   _delay_ms(200);
 172:main.c        ****   led0_off();
 173:main.c        ****   led2_on();
 174:main.c        ****   _delay_ms(200);
 175:main.c        ****   led1_off();
 176:main.c        ****   _delay_ms(200);
 177:main.c        ****   led2_off();
 178:main.c        **** 
 179:main.c        ****   shutdown_off();
 180:main.c        ****   raspi_off();
 181:main.c        ****   nfc_off();
 182:main.c        **** }
 183:main.c        **** 
 184:main.c        **** static volatile uint64_t seconds = 0;
 185:main.c        **** static volatile uint64_t button_pressed = 0;
 186:main.c        **** static volatile int wake_triggered = 0;
 187:main.c        **** static int shutdown_timeout = 0;
 188:main.c        **** 
 189:main.c        **** int main() {
 269               	.LM18:
 270               	.LFBB6:
 271               	/* prologue: function */
 272               	/* frame size = 0 */
 273               	/* stack size = 0 */
 274               	.L__stack_usage = 0
 190:main.c        ****   // safety precausion concerning watchdog reset:
 191:main.c        ****   if(MCUSR & _BV(WDRF)) { // If a reset was caused by the Watchdog Timer...
 276               	.LM19:
 277 0000 04B6      		in __tmp_reg__,0x34
 278 0002 03FE      		sbrs __tmp_reg__,3
 279 0004 00C0      		rjmp .L10
 192:main.c        ****     MCUSR &= ~_BV(WDRF);  // Clear the WDT reset flag
 281               	.LM20:
 282 0006 84B7      		in r24,0x34
 283 0008 877F      		andi r24,lo8(-9)
 284 000a 84BF      		out 0x34,r24
 193:main.c        ****     WDTCSR |= (_BV(WDCE) | _BV(WDE));   // Enable the WD Change Bit
 286               	.LM21:
 287 000c 81B5      		in r24,0x21
 288 000e 8861      		ori r24,lo8(24)
 289 0010 81BD      		out 0x21,r24
 194:main.c        ****     WDTCSR = 0x00;        // Disable the WDT
 291               	.LM22:
 292 0012 11BC      		out 0x21,__zero_reg__
 293               	.L10:
 294               	.LBB150:
 295               	.LBB151:
  47:main.c        ****   DDRA |= _BV(PIN_RASPI_ON) | _BV(PIN_NFC_ON);
 297               	.LM23:
 298 0014 1BBA      		out 0x1b,__zero_reg__
  48:main.c        **** 
 300               	.LM24:
 301 0016 8AB3      		in r24,0x1a
 302 0018 8360      		ori r24,lo8(3)
 303 001a 8ABB      		out 0x1a,r24
  50:main.c        ****   DDRB |= _BV(PIN_LED1)     | _BV(PIN_LED2) | _BV(PIN_GPIO17) | _BV(PIN_GPIO18);
 305               	.LM25:
 306 001c 18BA      		out 0x18,__zero_reg__
  51:main.c        ****   DDRB &= ~_BV(PIN_POWER_OK);
 308               	.LM26:
 309 001e 87B3      		in r24,0x17
 310 0020 8761      		ori r24,lo8(23)
 311 0022 87BB      		out 0x17,r24
  52:main.c        ****   //PORTB &= ~_BV(PIN_POWER_OK); // disable internal pull-up
 313               	.LM27:
 314 0024 BB98      		cbi 0x17,3
  54:main.c        **** 
 316               	.LM28:
 317 0026 86E0      		ldi r24,lo8(6)
 318 0028 88BB      		out 0x18,r24
  56:main.c        ****   //DDRD = _BV(PIN_LED0) | _BV(PIN_SHUTDOWN);
 320               	.LM29:
 321 002a 12BA      		out 0x12,__zero_reg__
  58:main.c        ****   //DDRD &= ~(_BV(PIN_BUTTON) | _BV(PIN_WAKE) | _BV(PIN_SHUTD_BUSY));
 323               	.LM30:
 324 002c 88E5      		ldi r24,lo8(88)
 325 002e 81BB      		out 0x11,r24
  61:main.c        **** 
 327               	.LM31:
 328 0030 84E1      		ldi r24,lo8(20)
 329 0032 82BB      		out 0x12,r24
  71:main.c        ****   GIMSK  = _BV(INT0);  // enable INT0 only; INT1 is only enabled when raspi is on
 331               	.LM32:
 332 0034 15BE      		out 0x35,__zero_reg__
  72:main.c        ****   //GIMSK = 0;
 334               	.LM33:
 335 0036 80E4      		ldi r24,lo8(64)
 336 0038 8BBF      		out 0x3b,r24
  78:main.c        **** 
 338               	.LM34:
 339 003a 85B7      		in r24,0x35
 340 003c 8F7A      		andi r24,lo8(-81)
 341 003e 85BF      		out 0x35,r24
  81:main.c        ****   WDTCSR =   _BV(WDIE) |              // Interupt Mode
 343               	.LM35:
 344 0040 81B5      		in r24,0x21
 345 0042 8861      		ori r24,lo8(24)
 346 0044 81BD      		out 0x21,r24
  82:main.c        ****              _BV(WDP2) | _BV(WDP1);   // Set Timeout to ~1 seconds
 348               	.LM36:
 349 0046 86E4      		ldi r24,lo8(70)
 350 0048 81BD      		out 0x21,r24
  85:main.c        **** }
 352               	.LM37:
 353               	/* #APP */
 354               	 ;  85 "main.c" 1
 355 004a 7894      		sei
 356               	 ;  0 "" 2
 357               	/* #NOAPP */
 358               	.LBE151:
 359               	.LBE150:
 360               	.LBB152:
 361               	.LBB153:
 167:main.c        ****   led0_on();
 363               	.LM38:
 364 004c 00D0      		rcall raspi_off
 365               	.LBB154:
 366               	.LBB155:
  89:main.c        **** }
 368               	.LM39:
 369 004e 969A      		sbi 0x12,6
 370 0050 80ED      		ldi r24,lo8(-48)
 371 0052 97E0      		ldi r25,lo8(7)
 372               	.LBE155:
 373               	.LBE154:
 374               	.LBB156:
 375               	.LBB157:
 376               	.LBB158:
 377               	.LBB159:
 379               	.Ltext4:
 381               	.LM40:
 382 0054 28EC      		ldi r18,lo8(-56)
 383 0056 30E0      		ldi r19,0
 384               	.L11:
 385 0058 F901      		movw r30,r18
 386               	/* #APP */
 387               	 ;  105 "/usr/lib/avr/include/util/delay_basic.h" 1
 388 005a 3197      		1: sbiw r30,1
 389 005c 01F4      		brne 1b
 390               	 ;  0 "" 2
 391               	/* #NOAPP */
 392 005e 0197      		sbiw r24,1
 393               	.LBE159:
 394               	.LBE158:
 396               	.Ltext5:
 398               	.LM41:
 399 0060 01F4      		brne .L11
 400               	.LBE157:
 401               	.LBE156:
 402               	.LBB160:
 403               	.LBB161:
 405               	.Ltext6:
 101:main.c        **** }
 407               	.LM42:
 408 0062 C49A      		sbi 0x18,4
 409 0064 80ED      		ldi r24,lo8(-48)
 410 0066 97E0      		ldi r25,lo8(7)
 411               	.LBE161:
 412               	.LBE160:
 413               	.LBB162:
 414               	.LBB163:
 415               	.LBB164:
 416               	.LBB165:
 418               	.Ltext7:
 420               	.LM43:
 421 0068 28EC      		ldi r18,lo8(-56)
 422 006a 30E0      		ldi r19,0
 423               	.L12:
 424 006c F901      		movw r30,r18
 425               	/* #APP */
 426               	 ;  105 "/usr/lib/avr/include/util/delay_basic.h" 1
 427 006e 3197      		1: sbiw r30,1
 428 0070 01F4      		brne 1b
 429               	 ;  0 "" 2
 430               	/* #NOAPP */
 431 0072 0197      		sbiw r24,1
 432               	.LBE165:
 433               	.LBE164:
 435               	.Ltext8:
 437               	.LM44:
 438 0074 01F4      		brne .L12
 439               	.LBE163:
 440               	.LBE162:
 442               	.Ltext9:
 172:main.c        ****   led2_on();
 444               	.LM45:
 445 0076 00D0      		rcall led0_off
 446               	.LBB166:
 447               	.LBB167:
 113:main.c        **** }
 449               	.LM46:
 450 0078 C09A      		sbi 0x18,0
 451 007a 80ED      		ldi r24,lo8(-48)
 452 007c 97E0      		ldi r25,lo8(7)
 453               	.LBE167:
 454               	.LBE166:
 455               	.LBB168:
 456               	.LBB169:
 457               	.LBB170:
 458               	.LBB171:
 460               	.Ltext10:
 462               	.LM47:
 463 007e 28EC      		ldi r18,lo8(-56)
 464 0080 30E0      		ldi r19,0
 465               	.L13:
 466 0082 F901      		movw r30,r18
 467               	/* #APP */
 468               	 ;  105 "/usr/lib/avr/include/util/delay_basic.h" 1
 469 0084 3197      		1: sbiw r30,1
 470 0086 01F4      		brne 1b
 471               	 ;  0 "" 2
 472               	/* #NOAPP */
 473 0088 0197      		sbiw r24,1
 474               	.LBE171:
 475               	.LBE170:
 477               	.Ltext11:
 479               	.LM48:
 480 008a 01F4      		brne .L13
 481               	.LBE169:
 482               	.LBE168:
 484               	.Ltext12:
 175:main.c        ****   _delay_ms(200);
 486               	.LM49:
 487 008c 00D0      		rcall led1_off
 488 008e 80ED      		ldi r24,lo8(-48)
 489 0090 97E0      		ldi r25,lo8(7)
 490               	.LBB172:
 491               	.LBB173:
 492               	.LBB174:
 493               	.LBB175:
 495               	.Ltext13:
 497               	.LM50:
 498 0092 28EC      		ldi r18,lo8(-56)
 499 0094 30E0      		ldi r19,0
 500               	.L14:
 501 0096 F901      		movw r30,r18
 502               	/* #APP */
 503               	 ;  105 "/usr/lib/avr/include/util/delay_basic.h" 1
 504 0098 3197      		1: sbiw r30,1
 505 009a 01F4      		brne 1b
 506               	 ;  0 "" 2
 507               	/* #NOAPP */
 508 009c 0197      		sbiw r24,1
 509               	.LBE175:
 510               	.LBE174:
 512               	.Ltext14:
 514               	.LM51:
 515 009e 01F4      		brne .L14
 516               	.LBE173:
 517               	.LBE172:
 519               	.Ltext15:
 177:main.c        **** 
 521               	.LM52:
 522 00a0 00D0      		rcall led2_off
 523               	.LBB176:
 524               	.LBB177:
 155:main.c        **** }
 526               	.LM53:
 527 00a2 949A      		sbi 0x12,4
 528               	.LBE177:
 529               	.LBE176:
 180:main.c        ****   nfc_off();
 531               	.LM54:
 532 00a4 00D0      		rcall raspi_off
 533               	.LBB178:
 534               	.LBB179:
 147:main.c        **** }
 536               	.LM55:
 537 00a6 D898      		cbi 0x1b,0
 538               	.LBE179:
 539               	.LBE178:
 540               	.LBE153:
 541               	.LBE152:
 195:main.c        ****   }
 196:main.c        **** 
 197:main.c        ****     
 198:main.c        ****   setup();
 199:main.c        ****   //uart_puts("Setup Complete.\r\n");  
 200:main.c        ****   main_init();
 201:main.c        ****   //uart_puts("Init Complete.\r\n");  
 202:main.c        **** 
 203:main.c        **** 
 204:main.c        ****   //nfc_on();
 205:main.c        ****   while (1) {
 206:main.c        ****     if (seconds - button_pressed > 3) {
 207:main.c        ****       button_pressed = 0;
 208:main.c        ****     }
 209:main.c        ****     switch (state) {
 210:main.c        ****         
 211:main.c        ****     case MC_BOOT:
 212:main.c        ****         led0_on();
 213:main.c        ****         led1_on();
 214:main.c        ****         led2_on();
 215:main.c        ****         if (is_power_ok()) {
 216:main.c        ****           state = MC_ON;
 217:main.c        ****           raspi_on();
 218:main.c        ****           nfc_on();
 219:main.c        ****         } else {
 220:main.c        ****           state = MC_OFF;
 221:main.c        ****         }
 222:main.c        ****         break;
 223:main.c        **** 
 224:main.c        ****     case MC_ON:
 225:main.c        ****         led0_toggle();
 226:main.c        ****         led1_off();
 227:main.c        ****         led2_off();
 228:main.c        ****         if (!is_power_ok()) {
 229:main.c        ****           shutdown_on();
 230:main.c        ****           nfc_off();
 231:main.c        ****           _delay_ms(500);
 232:main.c        ****           state = MC_WAIT_SHUTDOWN_BUSY;
 233:main.c        ****           shutdown_timeout = 120;
 234:main.c        ****           break;
 235:main.c        ****         }
 236:main.c        ****         if ((button_pressed > 0) && (seconds - button_pressed < 2)) {
 237:main.c        ****           button_pressed = 0;
 238:main.c        ****           shutdown_on();
 239:main.c        ****           nfc_off();
 240:main.c        ****           _delay_ms(500);
 241:main.c        ****           state = MC_WAIT_SHUTDOWN_BUSY;
 242:main.c        ****           shutdown_timeout = 120;
 243:main.c        ****         }
 244:main.c        ****         break;
 245:main.c        **** 
 246:main.c        ****     case MC_WAIT_SHUTDOWN_BUSY:
 247:main.c        ****         shutdown_timeout -= 1;
 248:main.c        ****         if (shutdown_timeout <= 0) {
 249:main.c        ****           shutdown_off();
 250:main.c        ****           state = MC_WAIT_SHUTDOWN_DONE;
 251:main.c        ****           break;
 252:main.c        ****         }
 253:main.c        ****         button_pressed = 0;
 254:main.c        ****         led0_off();
 255:main.c        ****         led1_toggle();
 256:main.c        ****         led2_off();
 257:main.c        ****         if (is_shutdown_busy()) {
 258:main.c        ****           shutdown_off();
 259:main.c        ****           state = MC_WAIT_SHUTDOWN_DONE;
 260:main.c        ****         }
 261:main.c        ****         break;
 262:main.c        **** 
 263:main.c        ****     case MC_WAIT_SHUTDOWN_DONE:
 264:main.c        ****         shutdown_timeout -= 1;
 265:main.c        ****         if (shutdown_timeout <= 0) {
 266:main.c        ****           raspi_off();
 267:main.c        ****           state = MC_OFF;
 543               	.LM56:
 544 00a8 84E0      		ldi r24,lo8(4)
 545 00aa 582E      		mov r5,r24
 546               	.LBB180:
 547               	.LBB181:
 548               	.LBB182:
 549               	.LBB183:
 551               	.Ltext16:
 553               	.LM57:
 554 00ac 90E2      		ldi r25,lo8(32)
 555 00ae 892E      		mov r8,r25
 556 00b0 9EE4      		ldi r25,lo8(78)
 557 00b2 992E      		mov r9,r25
 558               	.LBE183:
 559               	.LBE182:
 560               	.LBE181:
 561               	.LBE180:
 563               	.Ltext17:
 268:main.c        ****           break;
 269:main.c        ****         }
 270:main.c        ****         button_pressed = 0;
 271:main.c        ****         led0_off();
 272:main.c        ****         led1_off();
 273:main.c        ****         led2_toggle();
 274:main.c        ****         if (!is_shutdown_busy()) {
 275:main.c        ****           raspi_off();
 276:main.c        ****           state = MC_OFF;
 277:main.c        ****         }
 278:main.c        ****         break;
 279:main.c        **** 
 280:main.c        ****     case MC_OFF:
 281:main.c        ****         led0_on();
 282:main.c        ****         _delay_ms(10);
 283:main.c        ****         led0_off();
 284:main.c        ****         led1_off();
 285:main.c        ****         led2_off();
 286:main.c        ****         if (button_pressed > 0) {
 287:main.c        ****           button_pressed = 0;
 288:main.c        ****           if (is_power_ok()) {
 289:main.c        ****             raspi_on();
 290:main.c        ****             nfc_on();
 291:main.c        ****             state = MC_ON;
 565               	.LM58:
 566 00b4 4424      		clr r4
 567 00b6 4394      		inc r4
 568               	.LBB187:
 569               	.LBB188:
 570               	.LBB189:
 571               	.LBB190:
 573               	.Ltext18:
 575               	.LM59:
 576 00b8 C8EC      		ldi r28,lo8(-56)
 577 00ba D0E0      		ldi r29,0
 578               	.LBE190:
 579               	.LBE189:
 580               	.LBE188:
 581               	.LBE187:
 583               	.Ltext19:
 232:main.c        ****           shutdown_timeout = 120;
 585               	.LM60:
 586 00bc 22E0      		ldi r18,lo8(2)
 587 00be 322E      		mov r3,r18
 233:main.c        ****           break;
 589               	.LM61:
 590 00c0 38E7      		ldi r19,lo8(120)
 591 00c2 632E      		mov r6,r19
 592 00c4 712C      		mov r7,__zero_reg__
 593               	.L34:
 206:main.c        ****       button_pressed = 0;
 595               	.LM62:
 596 00c6 2091 0000 		lds r18,seconds
 597 00ca 3091 0000 		lds r19,seconds+1
 598 00ce 4091 0000 		lds r20,seconds+2
 599 00d2 5091 0000 		lds r21,seconds+3
 600 00d6 6091 0000 		lds r22,seconds+4
 601 00da 7091 0000 		lds r23,seconds+5
 602 00de 8091 0000 		lds r24,seconds+6
 603 00e2 9091 0000 		lds r25,seconds+7
 604 00e6 A090 0000 		lds r10,button_pressed
 605 00ea B090 0000 		lds r11,button_pressed+1
 606 00ee C090 0000 		lds r12,button_pressed+2
 607 00f2 D090 0000 		lds r13,button_pressed+3
 608 00f6 E090 0000 		lds r14,button_pressed+4
 609 00fa F090 0000 		lds r15,button_pressed+5
 610 00fe 0091 0000 		lds r16,button_pressed+6
 611 0102 1091 0000 		lds r17,button_pressed+7
 612 0106 00D0      		rcall __subdi3
 613 0108 A3E0      		ldi r26,lo8(3)
 614 010a 00D0      		rcall __cmpdi2_s8
 615 010c 01F0      		breq .L15
 616 010e 00F0      		brlo .L15
 207:main.c        ****     }
 618               	.LM63:
 619 0110 1092 0000 		sts button_pressed,__zero_reg__
 620 0114 1092 0000 		sts button_pressed+1,__zero_reg__
 621 0118 1092 0000 		sts button_pressed+2,__zero_reg__
 622 011c 1092 0000 		sts button_pressed+3,__zero_reg__
 623 0120 1092 0000 		sts button_pressed+4,__zero_reg__
 624 0124 1092 0000 		sts button_pressed+5,__zero_reg__
 625 0128 1092 0000 		sts button_pressed+6,__zero_reg__
 626 012c 1092 0000 		sts button_pressed+7,__zero_reg__
 627               	.L15:
 209:main.c        ****         
 629               	.LM64:
 630 0130 8091 0000 		lds r24,state
 631 0134 8230      		cpi r24,lo8(2)
 632 0136 01F4      		brne .+2
 633 0138 00C0      		rjmp .L17
 634 013a 00F4      		brsh .L18
 635 013c 8823      		tst r24
 636 013e 01F0      		breq .L19
 637 0140 8130      		cpi r24,lo8(1)
 638 0142 01F0      		breq .L20
 639 0144 00C0      		rjmp .L16
 640               	.L18:
 641 0146 8330      		cpi r24,lo8(3)
 642 0148 01F4      		brne .+2
 643 014a 00C0      		rjmp .L21
 644 014c 8430      		cpi r24,lo8(4)
 645 014e 01F4      		brne .+2
 646 0150 00C0      		rjmp .L22
 647 0152 00C0      		rjmp .L16
 648               	.L19:
 649               	.LBB194:
 650               	.LBB195:
  89:main.c        **** }
 652               	.LM65:
 653 0154 969A      		sbi 0x12,6
 654               	.LBE195:
 655               	.LBE194:
 656               	.LBB196:
 657               	.LBB197:
 101:main.c        **** }
 659               	.LM66:
 660 0156 C49A      		sbi 0x18,4
 661               	.LBE197:
 662               	.LBE196:
 663               	.LBB198:
 664               	.LBB199:
 113:main.c        **** }
 666               	.LM67:
 667 0158 C09A      		sbi 0x18,0
 668               	.LBE199:
 669               	.LBE198:
 215:main.c        ****           state = MC_ON;
 671               	.LM68:
 672 015a B39B      		sbis 0x16,3
 673 015c 00C0      		rjmp .L54
 216:main.c        ****           raspi_on();
 675               	.LM69:
 676 015e 4092 0000 		sts state,r4
 217:main.c        ****           nfc_on();
 678               	.LM70:
 679 0162 00D0      		rcall raspi_on
 680               	.LBB200:
 681               	.LBB201:
 143:main.c        **** }
 683               	.LM71:
 684 0164 D89A      		sbi 0x1b,0
 685 0166 00C0      		rjmp .L16
 686               	.L20:
 687               	.LBE201:
 688               	.LBE200:
 689               	.LBB202:
 690               	.LBB203:
  97:main.c        **** }
 692               	.LM72:
 693 0168 869A      		sbi 0x10,6
 694               	.LBE203:
 695               	.LBE202:
 226:main.c        ****         led2_off();
 697               	.LM73:
 698 016a 00D0      		rcall led1_off
 227:main.c        ****         if (!is_power_ok()) {
 700               	.LM74:
 701 016c 00D0      		rcall led2_off
 228:main.c        ****           shutdown_on();
 703               	.LM75:
 704 016e B399      		sbic 0x16,3
 705 0170 00C0      		rjmp .L24
 706               	.LBB204:
 707               	.LBB205:
 151:main.c        **** }
 709               	.LM76:
 710 0172 9498      		cbi 0x12,4
 711               	.LBE205:
 712               	.LBE204:
 713               	.LBB206:
 714               	.LBB207:
 147:main.c        **** }
 716               	.LM77:
 717 0174 D898      		cbi 0x1b,0
 718 0176 88E8      		ldi r24,lo8(-120)
 719 0178 93E1      		ldi r25,lo8(19)
 720               	.L25:
 721               	.LBE207:
 722               	.LBE206:
 723               	.LBB208:
 724               	.LBB209:
 725               	.LBB210:
 726               	.LBB211:
 728               	.Ltext20:
 730               	.LM78:
 731 017a FE01      		movw r30,r28
 732               	/* #APP */
 733               	 ;  105 "/usr/lib/avr/include/util/delay_basic.h" 1
 734 017c 3197      		1: sbiw r30,1
 735 017e 01F4      		brne 1b
 736               	 ;  0 "" 2
 737               	/* #NOAPP */
 738 0180 0197      		sbiw r24,1
 739               	.LBE211:
 740               	.LBE210:
 742               	.Ltext21:
 744               	.LM79:
 745 0182 01F4      		brne .L25
 746               	.L29:
 747               	.LBE209:
 748               	.LBE208:
 750               	.Ltext22:
 232:main.c        ****           shutdown_timeout = 120;
 752               	.LM80:
 753 0184 3092 0000 		sts state,r3
 233:main.c        ****           break;
 755               	.LM81:
 756 0188 7092 0000 		sts shutdown_timeout+1,r7
 757 018c 6092 0000 		sts shutdown_timeout,r6
 234:main.c        ****         }
 759               	.LM82:
 760 0190 00C0      		rjmp .L16
 761               	.L24:
 236:main.c        ****           button_pressed = 0;
 763               	.LM83:
 764 0192 2091 0000 		lds r18,button_pressed
 765 0196 3091 0000 		lds r19,button_pressed+1
 766 019a 4091 0000 		lds r20,button_pressed+2
 767 019e 5091 0000 		lds r21,button_pressed+3
 768 01a2 6091 0000 		lds r22,button_pressed+4
 769 01a6 7091 0000 		lds r23,button_pressed+5
 770 01aa 8091 0000 		lds r24,button_pressed+6
 771 01ae 9091 0000 		lds r25,button_pressed+7
 772 01b2 A0E0      		ldi r26,0
 773 01b4 00D0      		rcall __cmpdi2_s8
 774 01b6 01F4      		brne .+2
 775 01b8 00C0      		rjmp .L16
 236:main.c        ****           button_pressed = 0;
 777               	.LM84:
 778 01ba 2091 0000 		lds r18,seconds
 779 01be 3091 0000 		lds r19,seconds+1
 780 01c2 4091 0000 		lds r20,seconds+2
 781 01c6 5091 0000 		lds r21,seconds+3
 782 01ca 6091 0000 		lds r22,seconds+4
 783 01ce 7091 0000 		lds r23,seconds+5
 784 01d2 8091 0000 		lds r24,seconds+6
 785 01d6 9091 0000 		lds r25,seconds+7
 786 01da A090 0000 		lds r10,button_pressed
 787 01de B090 0000 		lds r11,button_pressed+1
 788 01e2 C090 0000 		lds r12,button_pressed+2
 789 01e6 D090 0000 		lds r13,button_pressed+3
 790 01ea E090 0000 		lds r14,button_pressed+4
 791 01ee F090 0000 		lds r15,button_pressed+5
 792 01f2 0091 0000 		lds r16,button_pressed+6
 793 01f6 1091 0000 		lds r17,button_pressed+7
 794 01fa 00D0      		rcall __subdi3
 795 01fc A1E0      		ldi r26,lo8(1)
 796 01fe 00D0      		rcall __cmpdi2_s8
 797 0200 01F0      		breq .+4
 798 0202 00F0      		brlo .+2
 799 0204 00C0      		rjmp .L16
 237:main.c        ****           shutdown_on();
 801               	.LM85:
 802 0206 1092 0000 		sts button_pressed,__zero_reg__
 803 020a 1092 0000 		sts button_pressed+1,__zero_reg__
 804 020e 1092 0000 		sts button_pressed+2,__zero_reg__
 805 0212 1092 0000 		sts button_pressed+3,__zero_reg__
 806 0216 1092 0000 		sts button_pressed+4,__zero_reg__
 807 021a 1092 0000 		sts button_pressed+5,__zero_reg__
 808 021e 1092 0000 		sts button_pressed+6,__zero_reg__
 809 0222 1092 0000 		sts button_pressed+7,__zero_reg__
 810               	.LBB212:
 811               	.LBB213:
 151:main.c        **** }
 813               	.LM86:
 814 0226 9498      		cbi 0x12,4
 815               	.LBE213:
 816               	.LBE212:
 817               	.LBB214:
 818               	.LBB215:
 147:main.c        **** }
 820               	.LM87:
 821 0228 D898      		cbi 0x1b,0
 822 022a 88E8      		ldi r24,lo8(-120)
 823 022c 93E1      		ldi r25,lo8(19)
 824               	.L28:
 825               	.LBE215:
 826               	.LBE214:
 827               	.LBB216:
 828               	.LBB217:
 829               	.LBB218:
 830               	.LBB219:
 832               	.Ltext23:
 834               	.LM88:
 835 022e FE01      		movw r30,r28
 836               	/* #APP */
 837               	 ;  105 "/usr/lib/avr/include/util/delay_basic.h" 1
 838 0230 3197      		1: sbiw r30,1
 839 0232 01F4      		brne 1b
 840               	 ;  0 "" 2
 841               	/* #NOAPP */
 842 0234 0197      		sbiw r24,1
 843               	.LBE219:
 844               	.LBE218:
 846               	.Ltext24:
 848               	.LM89:
 849 0236 01F4      		brne .L28
 850 0238 00C0      		rjmp .L29
 851               	.L17:
 852               	.LBE217:
 853               	.LBE216:
 855               	.Ltext25:
 247:main.c        ****         if (shutdown_timeout <= 0) {
 857               	.LM90:
 858 023a 8091 0000 		lds r24,shutdown_timeout
 859 023e 9091 0000 		lds r25,shutdown_timeout+1
 860 0242 0197      		sbiw r24,1
 861 0244 9093 0000 		sts shutdown_timeout+1,r25
 862 0248 8093 0000 		sts shutdown_timeout,r24
 248:main.c        ****           shutdown_off();
 864               	.LM91:
 865 024c 1816      		cp __zero_reg__,r24
 866 024e 1906      		cpc __zero_reg__,r25
 867 0250 04F4      		brge .L55
 253:main.c        ****         led0_off();
 869               	.LM92:
 870 0252 1092 0000 		sts button_pressed,__zero_reg__
 871 0256 1092 0000 		sts button_pressed+1,__zero_reg__
 872 025a 1092 0000 		sts button_pressed+2,__zero_reg__
 873 025e 1092 0000 		sts button_pressed+3,__zero_reg__
 874 0262 1092 0000 		sts button_pressed+4,__zero_reg__
 875 0266 1092 0000 		sts button_pressed+5,__zero_reg__
 876 026a 1092 0000 		sts button_pressed+6,__zero_reg__
 877 026e 1092 0000 		sts button_pressed+7,__zero_reg__
 254:main.c        ****         led1_toggle();
 879               	.LM93:
 880 0272 00D0      		rcall led0_off
 881               	.LBB220:
 882               	.LBB221:
 109:main.c        **** } 
 884               	.LM94:
 885 0274 B49A      		sbi 0x16,4
 886               	.LBE221:
 887               	.LBE220:
 256:main.c        ****         if (is_shutdown_busy()) {
 889               	.LM95:
 890 0276 00D0      		rcall led2_off
 257:main.c        ****           shutdown_off();
 892               	.LM96:
 893 0278 859B      		sbis 0x10,5
 894 027a 00C0      		rjmp .L16
 895               	.L55:
 896               	.LBB222:
 897               	.LBB223:
 155:main.c        **** }
 899               	.LM97:
 900 027c 949A      		sbi 0x12,4
 901               	.LBE223:
 902               	.LBE222:
 259:main.c        ****         }
 904               	.LM98:
 905 027e 83E0      		ldi r24,lo8(3)
 906 0280 8093 0000 		sts state,r24
 907 0284 00C0      		rjmp .L16
 908               	.L21:
 264:main.c        ****         if (shutdown_timeout <= 0) {
 910               	.LM99:
 911 0286 8091 0000 		lds r24,shutdown_timeout
 912 028a 9091 0000 		lds r25,shutdown_timeout+1
 913 028e 0197      		sbiw r24,1
 914 0290 9093 0000 		sts shutdown_timeout+1,r25
 915 0294 8093 0000 		sts shutdown_timeout,r24
 265:main.c        ****           raspi_off();
 917               	.LM100:
 918 0298 1816      		cp __zero_reg__,r24
 919 029a 1906      		cpc __zero_reg__,r25
 920 029c 04F0      		brlt .L31
 921               	.L32:
 266:main.c        ****           state = MC_OFF;
 923               	.LM101:
 924 029e 00D0      		rcall raspi_off
 925               	.L54:
 267:main.c        ****           break;
 927               	.LM102:
 928 02a0 5092 0000 		sts state,r5
 268:main.c        ****         }
 930               	.LM103:
 931 02a4 00C0      		rjmp .L16
 932               	.L31:
 270:main.c        ****         led0_off();
 934               	.LM104:
 935 02a6 1092 0000 		sts button_pressed,__zero_reg__
 936 02aa 1092 0000 		sts button_pressed+1,__zero_reg__
 937 02ae 1092 0000 		sts button_pressed+2,__zero_reg__
 938 02b2 1092 0000 		sts button_pressed+3,__zero_reg__
 939 02b6 1092 0000 		sts button_pressed+4,__zero_reg__
 940 02ba 1092 0000 		sts button_pressed+5,__zero_reg__
 941 02be 1092 0000 		sts button_pressed+6,__zero_reg__
 942 02c2 1092 0000 		sts button_pressed+7,__zero_reg__
 271:main.c        ****         led1_off();
 944               	.LM105:
 945 02c6 00D0      		rcall led0_off
 272:main.c        ****         led2_toggle();
 947               	.LM106:
 948 02c8 00D0      		rcall led1_off
 949               	.LBB224:
 950               	.LBB225:
 121:main.c        **** } 
 952               	.LM107:
 953 02ca B09A      		sbi 0x16,0
 954               	.LBE225:
 955               	.LBE224:
 274:main.c        ****           raspi_off();
 957               	.LM108:
 958 02cc 8599      		sbic 0x10,5
 959 02ce 00C0      		rjmp .L16
 960 02d0 00C0      		rjmp .L32
 961               	.L22:
 962               	.LBB226:
 963               	.LBB227:
  89:main.c        **** }
 965               	.LM109:
 966 02d2 969A      		sbi 0x12,6
 967               	.LBE227:
 968               	.LBE226:
 969               	.LBB228:
 970               	.LBB186:
 971               	.LBB185:
 972               	.LBB184:
 974               	.Ltext26:
 976               	.LM110:
 977 02d4 C401      		movw r24,r8
 978               	/* #APP */
 979               	 ;  105 "/usr/lib/avr/include/util/delay_basic.h" 1
 980 02d6 0197      		1: sbiw r24,1
 981 02d8 01F4      		brne 1b
 982               	 ;  0 "" 2
 983               	/* #NOAPP */
 984               	.LBE184:
 985               	.LBE185:
 986               	.LBE186:
 987               	.LBE228:
 989               	.Ltext27:
 283:main.c        ****         led1_off();
 991               	.LM111:
 992 02da 00D0      		rcall led0_off
 284:main.c        ****         led2_off();
 994               	.LM112:
 995 02dc 00D0      		rcall led1_off
 285:main.c        ****         if (button_pressed > 0) {
 997               	.LM113:
 998 02de 00D0      		rcall led2_off
 286:main.c        ****           button_pressed = 0;
 1000               	.LM114:
 1001 02e0 2091 0000 		lds r18,button_pressed
 1002 02e4 3091 0000 		lds r19,button_pressed+1
 1003 02e8 4091 0000 		lds r20,button_pressed+2
 1004 02ec 5091 0000 		lds r21,button_pressed+3
 1005 02f0 6091 0000 		lds r22,button_pressed+4
 1006 02f4 7091 0000 		lds r23,button_pressed+5
 1007 02f8 8091 0000 		lds r24,button_pressed+6
 1008 02fc 9091 0000 		lds r25,button_pressed+7
 1009 0300 A0E0      		ldi r26,0
 1010 0302 00D0      		rcall __cmpdi2_s8
 1011 0304 01F0      		breq .L16
 287:main.c        ****           if (is_power_ok()) {
 1013               	.LM115:
 1014 0306 1092 0000 		sts button_pressed,__zero_reg__
 1015 030a 1092 0000 		sts button_pressed+1,__zero_reg__
 1016 030e 1092 0000 		sts button_pressed+2,__zero_reg__
 1017 0312 1092 0000 		sts button_pressed+3,__zero_reg__
 1018 0316 1092 0000 		sts button_pressed+4,__zero_reg__
 1019 031a 1092 0000 		sts button_pressed+5,__zero_reg__
 1020 031e 1092 0000 		sts button_pressed+6,__zero_reg__
 1021 0322 1092 0000 		sts button_pressed+7,__zero_reg__
 288:main.c        ****             raspi_on();
 1023               	.LM116:
 1024 0326 B39B      		sbis 0x16,3
 1025 0328 00C0      		rjmp .L16
 289:main.c        ****             nfc_on();
 1027               	.LM117:
 1028 032a 00D0      		rcall raspi_on
 1029               	.LBB229:
 1030               	.LBB230:
 143:main.c        **** }
 1032               	.LM118:
 1033 032c D89A      		sbi 0x1b,0
 1034               	.LBE230:
 1035               	.LBE229:
 1037               	.LM119:
 1038 032e 4092 0000 		sts state,r4
 1039 0332 88E8      		ldi r24,lo8(-120)
 1040 0334 93E1      		ldi r25,lo8(19)
 1041               	.L33:
 1042               	.LBB231:
 1043               	.LBB193:
 1044               	.LBB192:
 1045               	.LBB191:
 1047               	.Ltext28:
 1049               	.LM120:
 1050 0336 FE01      		movw r30,r28
 1051               	/* #APP */
 1052               	 ;  105 "/usr/lib/avr/include/util/delay_basic.h" 1
 1053 0338 3197      		1: sbiw r30,1
 1054 033a 01F4      		brne 1b
 1055               	 ;  0 "" 2
 1056               	/* #NOAPP */
 1057 033c 0197      		sbiw r24,1
 1058               	.LBE191:
 1059               	.LBE192:
 1061               	.Ltext29:
 1063               	.LM121:
 1064 033e 01F4      		brne .L33
 1065               	.LBE193:
 1066               	.LBE231:
 1068               	.Ltext30:
 292:main.c        ****             _delay_ms(500);
 293:main.c        ****             button_pressed = 0;
 1070               	.LM122:
 1071 0340 1092 0000 		sts button_pressed,__zero_reg__
 1072 0344 1092 0000 		sts button_pressed+1,__zero_reg__
 1073 0348 1092 0000 		sts button_pressed+2,__zero_reg__
 1074 034c 1092 0000 		sts button_pressed+3,__zero_reg__
 1075 0350 1092 0000 		sts button_pressed+4,__zero_reg__
 1076 0354 1092 0000 		sts button_pressed+5,__zero_reg__
 1077 0358 1092 0000 		sts button_pressed+6,__zero_reg__
 1078 035c 1092 0000 		sts button_pressed+7,__zero_reg__
 1079               	.L16:
 294:main.c        ****           }
 295:main.c        ****         }        
 296:main.c        ****     }
 297:main.c        ****     sleep_mode(); // wait for interrupt or UART RX
 1081               	.LM123:
 1082 0360 85B7      		in r24,0x35
 1083 0362 8062      		ori r24,lo8(32)
 1084 0364 85BF      		out 0x35,r24
 1085               	/* #APP */
 1086               	 ;  297 "main.c" 1
 1087 0366 8895      		sleep
 1088               		
 1089               	 ;  0 "" 2
 1090               	/* #NOAPP */
 1091 0368 85B7      		in r24,0x35
 1092 036a 8F7D      		andi r24,lo8(-33)
 1093 036c 85BF      		out 0x35,r24
 298:main.c        **** 
 299:main.c        ****     /*const uint16_t c = uart_getc();
 300:main.c        ****     if (c == UART_NO_DATA) {
 301:main.c        ****       uart_putc('A');
 302:main.c        ****     }
 303:main.c        ****     else {
 304:main.c        ****       uart_putc(c);
 305:main.c        ****     }*/
 306:main.c        ****     
 307:main.c        ****   }
 1095               	.LM124:
 1096 036e 00C0      		rjmp .L34
 1098               	.Lscope6:
 1100               		.stabd	78,0,0
 1101               		.text
 1103               	.global	__vector_1
 1105               	__vector_1:
 1106               		.stabd	46,0,0
 308:main.c        **** 
 309:main.c        ****   return 0;
 310:main.c        **** 
 311:main.c        **** }
 312:main.c        **** 
 313:main.c        **** ISR(INT0_vect) {
 1108               	.LM125:
 1109               	.LFBB7:
 1110 003a 1F92      		push r1
 1111 003c 0F92      		push r0
 1112 003e 0FB6      		in r0,__SREG__
 1113 0040 0F92      		push r0
 1114 0042 1124      		clr __zero_reg__
 1115 0044 2F93      		push r18
 1116 0046 3F93      		push r19
 1117 0048 4F93      		push r20
 1118 004a 5F93      		push r21
 1119 004c 6F93      		push r22
 1120 004e 7F93      		push r23
 1121 0050 8F93      		push r24
 1122 0052 9F93      		push r25
 1123 0054 AF93      		push r26
 1124               	/* prologue: Signal */
 1125               	/* frame size = 0 */
 1126               	/* stack size = 12 */
 1127               	.L__stack_usage = 12
 314:main.c        ****   if (button_pressed == 0) { button_pressed = seconds; }
 1129               	.LM126:
 1130 0056 2091 0000 		lds r18,button_pressed
 1131 005a 3091 0000 		lds r19,button_pressed+1
 1132 005e 4091 0000 		lds r20,button_pressed+2
 1133 0062 5091 0000 		lds r21,button_pressed+3
 1134 0066 6091 0000 		lds r22,button_pressed+4
 1135 006a 7091 0000 		lds r23,button_pressed+5
 1136 006e 8091 0000 		lds r24,button_pressed+6
 1137 0072 9091 0000 		lds r25,button_pressed+7
 1138 0076 A0E0      		ldi r26,0
 1139 0078 00D0      		rcall __cmpdi2_s8
 1140 007a 01F4      		brne .L56
 1142               	.LM127:
 1143 007c 7091 0000 		lds r23,seconds
 1144 0080 6091 0000 		lds r22,seconds+1
 1145 0084 5091 0000 		lds r21,seconds+2
 1146 0088 4091 0000 		lds r20,seconds+3
 1147 008c 3091 0000 		lds r19,seconds+4
 1148 0090 2091 0000 		lds r18,seconds+5
 1149 0094 9091 0000 		lds r25,seconds+6
 1150 0098 8091 0000 		lds r24,seconds+7
 1151 009c 7093 0000 		sts button_pressed,r23
 1152 00a0 6093 0000 		sts button_pressed+1,r22
 1153 00a4 5093 0000 		sts button_pressed+2,r21
 1154 00a8 4093 0000 		sts button_pressed+3,r20
 1155 00ac 3093 0000 		sts button_pressed+4,r19
 1156 00b0 2093 0000 		sts button_pressed+5,r18
 1157 00b4 9093 0000 		sts button_pressed+6,r25
 1158 00b8 8093 0000 		sts button_pressed+7,r24
 1159               	.L56:
 1160               	/* epilogue start */
 315:main.c        **** }
 1162               	.LM128:
 1163 00bc AF91      		pop r26
 1164 00be 9F91      		pop r25
 1165 00c0 8F91      		pop r24
 1166 00c2 7F91      		pop r23
 1167 00c4 6F91      		pop r22
 1168 00c6 5F91      		pop r21
 1169 00c8 4F91      		pop r20
 1170 00ca 3F91      		pop r19
 1171 00cc 2F91      		pop r18
 1172 00ce 0F90      		pop r0
 1173 00d0 0FBE      		out __SREG__,r0
 1174 00d2 0F90      		pop r0
 1175 00d4 1F90      		pop r1
 1176 00d6 1895      		reti
 1178               	.Lscope7:
 1180               		.stabd	78,0,0
 1182               	.global	__vector_2
 1184               	__vector_2:
 1185               		.stabd	46,0,0
 316:main.c        **** 
 317:main.c        **** ISR(INT1_vect) { 
 1187               	.LM129:
 1188               	.LFBB8:
 1189 00d8 1F92      		push r1
 1190 00da 0F92      		push r0
 1191 00dc 0FB6      		in r0,__SREG__
 1192 00de 0F92      		push r0
 1193 00e0 1124      		clr __zero_reg__
 1194 00e2 8F93      		push r24
 1195 00e4 9F93      		push r25
 1196               	/* prologue: Signal */
 1197               	/* frame size = 0 */
 1198               	/* stack size = 5 */
 1199               	.L__stack_usage = 5
 318:main.c        ****   wake_triggered = 1;
 1201               	.LM130:
 1202 00e6 81E0      		ldi r24,lo8(1)
 1203 00e8 90E0      		ldi r25,0
 1204 00ea 9093 0000 		sts wake_triggered+1,r25
 1205 00ee 8093 0000 		sts wake_triggered,r24
 1206               	/* epilogue start */
 319:main.c        **** }
 1208               	.LM131:
 1209 00f2 9F91      		pop r25
 1210 00f4 8F91      		pop r24
 1211 00f6 0F90      		pop r0
 1212 00f8 0FBE      		out __SREG__,r0
 1213 00fa 0F90      		pop r0
 1214 00fc 1F90      		pop r1
 1215 00fe 1895      		reti
 1217               	.Lscope8:
 1219               		.stabd	78,0,0
 1221               	.global	__vector_18
 1223               	__vector_18:
 1224               		.stabd	46,0,0
 320:main.c        **** 
 321:main.c        **** ISR(WDT_OVERFLOW_vect) {
 1226               	.LM132:
 1227               	.LFBB9:
 1228 0100 1F92      		push r1
 1229 0102 0F92      		push r0
 1230 0104 0FB6      		in r0,__SREG__
 1231 0106 0F92      		push r0
 1232 0108 1124      		clr __zero_reg__
 1233 010a 2F93      		push r18
 1234 010c 3F93      		push r19
 1235 010e 4F93      		push r20
 1236 0110 5F93      		push r21
 1237 0112 6F93      		push r22
 1238 0114 7F93      		push r23
 1239 0116 8F93      		push r24
 1240 0118 9F93      		push r25
 1241 011a AF93      		push r26
 1242               	/* prologue: Signal */
 1243               	/* frame size = 0 */
 1244               	/* stack size = 12 */
 1245               	.L__stack_usage = 12
 322:main.c        ****   ++seconds;
 1247               	.LM133:
 1248 011c 2091 0000 		lds r18,seconds
 1249 0120 3091 0000 		lds r19,seconds+1
 1250 0124 4091 0000 		lds r20,seconds+2
 1251 0128 5091 0000 		lds r21,seconds+3
 1252 012c 6091 0000 		lds r22,seconds+4
 1253 0130 7091 0000 		lds r23,seconds+5
 1254 0134 8091 0000 		lds r24,seconds+6
 1255 0138 9091 0000 		lds r25,seconds+7
 1256 013c A1E0      		ldi r26,lo8(1)
 1257 013e 00D0      		rcall __adddi3_s8
 1258 0140 2093 0000 		sts seconds,r18
 1259 0144 3093 0000 		sts seconds+1,r19
 1260 0148 4093 0000 		sts seconds+2,r20
 1261 014c 5093 0000 		sts seconds+3,r21
 1262 0150 6093 0000 		sts seconds+4,r22
 1263 0154 7093 0000 		sts seconds+5,r23
 1264 0158 8093 0000 		sts seconds+6,r24
 1265 015c 9093 0000 		sts seconds+7,r25
 1266               	/* epilogue start */
 323:main.c        **** }
 1268               	.LM134:
 1269 0160 AF91      		pop r26
 1270 0162 9F91      		pop r25
 1271 0164 8F91      		pop r24
 1272 0166 7F91      		pop r23
 1273 0168 6F91      		pop r22
 1274 016a 5F91      		pop r21
 1275 016c 4F91      		pop r20
 1276 016e 3F91      		pop r19
 1277 0170 2F91      		pop r18
 1278 0172 0F90      		pop r0
 1279 0174 0FBE      		out __SREG__,r0
 1280 0176 0F90      		pop r0
 1281 0178 1F90      		pop r1
 1282 017a 1895      		reti
 1284               	.Lscope9:
 1286               		.stabd	78,0,0
 1287               		.local	shutdown_timeout
 1288               		.comm	shutdown_timeout,2,1
 1289               		.local	wake_triggered
 1290               		.comm	wake_triggered,2,1
 1291               		.local	button_pressed
 1292               		.comm	button_pressed,8,1
 1293               		.local	seconds
 1294               		.comm	seconds,8,1
 1295               		.local	state
 1296               		.comm	state,1,1
 1303               	.Letext0:
 1304               		.ident	"GCC: (GNU) 4.9.2"
 1305               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccwMIfa0.s:2      *ABS*:000000000000003d __SP_L__
     /tmp/ccwMIfa0.s:3      *ABS*:000000000000003f __SREG__
     /tmp/ccwMIfa0.s:4      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccwMIfa0.s:5      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccwMIfa0.s:115    .text:0000000000000000 led0_off
     /tmp/ccwMIfa0.s:134    .text:0000000000000004 led1_off
     /tmp/ccwMIfa0.s:153    .text:0000000000000008 led2_off
     /tmp/ccwMIfa0.s:172    .text:000000000000000c raspi_on
     /tmp/ccwMIfa0.s:234    .text:000000000000002c raspi_off
     /tmp/ccwMIfa0.s:266    .text.startup:0000000000000000 main
     /tmp/ccwMIfa0.s:1292   .bss:000000000000000c seconds
     /tmp/ccwMIfa0.s:1290   .bss:0000000000000004 button_pressed
     /tmp/ccwMIfa0.s:1294   .bss:0000000000000014 state
                             .bss:0000000000000000 shutdown_timeout
     /tmp/ccwMIfa0.s:1105   .text:000000000000003a __vector_1
     /tmp/ccwMIfa0.s:1184   .text:00000000000000d8 __vector_2
     /tmp/ccwMIfa0.s:1288   .bss:0000000000000002 wake_triggered
     /tmp/ccwMIfa0.s:1223   .text:0000000000000100 __vector_18

UNDEFINED SYMBOLS
__subdi3
__cmpdi2_s8
__adddi3_s8
__do_clear_bss
